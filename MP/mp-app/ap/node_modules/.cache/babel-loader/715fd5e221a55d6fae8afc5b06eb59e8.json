{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\nvar DataDimensionInfo = require(\"./DataDimensionInfo\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object|module:data/DataDimensionInfo>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function List(dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo({\n        name: dimensionInfo\n      });\n    } else if (!(dimensionInfo instanceof DataDimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo(dimensionInfo);\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n  /**\n   * User output info of this data.\n   * DO NOT use it in other places!\n   *\n   * When preparing user params for user callbacks, we have\n   * to clone these inner data structures to prevent users\n   * from modifying them to effect built-in logic. And for\n   * performance consideration we make this `userOutput` to\n   * avoid clone them too many times.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.userOutput = this._dimensionsSummary.userOutput;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * The meanings of the input parameter `dim`:\n *\n * + If dim is a number (e.g., `1`), it means the index of the dimension.\n *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n * + If dim is a number-like string (e.g., `\"1\"`):\n *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n *     + If not, it will be converted to a number, which means the index of the dimension.\n *        (why? because of the backward compatbility. We have been tolerating number-like string in\n *        dimension setting, although now it seems that it is not a good idea.)\n *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n *     if no dimension name is defined as `\"1\"`.\n * + If dim is a not-number-like string, it means the concrete dim name.\n *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n *   or customized in `dimensions` property of option like `\"age\"`.\n *\n * Get dimension name\n * @param {string|number} dim See above.\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n    dim = this.dimensions[dim];\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        default label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    // Ordinal type originally can be string or number.\n    // But when an ordinal type is used on coord, it can\n    // not be string but only number. So we can also use isNaN.\n    if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  }\n\n  if (!this._indices) {\n    return rawIndex;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} If and only if multiple indices has\n *        the same value, they are put to the result.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Infinity;\n  var minDiff = -1;\n  var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i);\n    var dist = Math.abs(diff);\n\n    if (dist <= maxDistance) {\n      // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n      // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n      // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n      // So we chose the one that `diff >= 0` in this csae.\n      // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n      // should be push to `nearestIndices`.\n      if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndicesLen = 0;\n      }\n\n      if (diff === minDiff) {\n        nearestIndices[nearestIndicesLen++] = i;\n      }\n    }\n  }\n\n  nearestIndices.length = nearestIndicesLen;\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function setItemDataAndSeriesIndex(child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/data/List.js"],"names":["_config","require","__DEV__","zrUtil","Model","DataDiffer","Source","_dataProvider","defaultDimValueGetters","DefaultDataProvider","_dimensionHelper","summarizeDimensions","DataDimensionInfo","isObject","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","getIndicesCtor","list","_rawCount","cloneChunk","originalChunk","Ctor","constructor","slice","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","transferProperties","target","source","each","concat","__wrappedMethods","propName","hasOwnProperty","clone","_calculationInfo","extend","List","dimensions","hostModel","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimensionInfo","isString","name","dimensionName","type","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","_dimensionInfos","dataType","_indices","_count","_storage","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","hasItemVisual","_itemLayouts","_graphicEls","_chunkSize","_chunkCount","_rawData","_rawExtent","_extent","_approximateExtent","_dimensionsSummary","_invertedIndicesMap","userOutput","listProto","prototype","hasItemOption","getDimension","dim","isNaN","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","initData","data","nameList","dimValueGetter","notProvider","isInstance","isArrayLike","_nameRepeatCount","defaultDimValueGetter","getSource","sourceFormat","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","count","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","chunkSize","storage","dimLen","rawExtent","Math","max","originalChunkCount","getInitialExtent","prepareChunks","emptyDataItem","sourceIdx","chunkIndex","floor","chunkOffset","k","val","dimRawExtent","prepareInvertedIndex","dimensionInfoMap","idList","nameRepeatCount","nameDimIdx","dimInfo","itemName","_nameDimIdx","itemId","_idDimIdx","dataItem","getItem","dimStorage","nameDim","nameDimChunk","ordinalMeta","categories","id","clean","chunkCount","DataCtor","lastChunkIndex","resizeChunkArray","newStore","min","j","invertedIndices","get","getRawValueFromStore","dimIndex","rawIndex","chunk","getIndices","newIndices","indices","thisCount","buffer","NaN","getRawIndex","chunkStore","value","getByRawIndex","rawIdx","dimStore","_getFast","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","getSum","sum","getMedian","dimDataArray","sortedDimDataArray","sort","a","b","rawIndexOf","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","minDiff","nearestIndicesLen","diff","dist","abs","getRawIndexWithoutIndices","getRawIndexWithIndices","getRawDataItem","getId","normalizeDimensions","validateDimensions","console","error","cb","context","contextCompat","map","dimSize","call","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","chunkStorage","dimStorage2","min2","max2","chunkStorage2","val2","dimk","mapArray","result","arguments","cloneListForMapAndSample","original","excludeDimensions","allDimensions","originalStorage","indexOf","cloneDimStore","originalDimStore","newDimStore","tmpRetValue","dataCount","dataIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","originalChunkIndex","originalChunkOffset","sampleFrameIdx","sampleChunkIndex","sampleChunkOffset","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","getItemVisual","ignoreParent","itemVisual","setItemVisual","clearAllVisual","setItemDataAndSeriesIndex","child","seriesIndex","setItemGraphicEl","el","traverse","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","_default","module","exports"],"mappings":"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AApC;AACD;AACF;AACD;AACF;AACA;AACA;;;AAGE,OAAKV,UAAL,GAAkBG,cAAlB;AACA;AACF;AACA;AACA;;AAEE,OAAKe,eAAL,GAAuBhB,cAAvB;AACA;AACF;AACA;;AAEE,OAAKD,SAAL,GAAiBA,SAAjB;AACA;AACF;AACA;;AAEE,OAAKkB,QAAL;AACA;AACF;AACA;AACA;AACA;AACA;;AAEE,OAAKC,QAAL,GAAgB,IAAhB;AACA,OAAKC,MAAL,GAAc,CAAd;AACA,OAAKzC,SAAL,GAAiB,CAAjB;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAK0C,QAAL,GAAgB,EAAhB;AACA;AACF;AACA;;AAEE,OAAKC,SAAL,GAAiB,EAAjB;AACA;AACF;AACA;;AAEE,OAAKC,OAAL,GAAe,EAAf;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,aAAL,GAAqB,EAArB;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,OAAL,GAAe,EAAf;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,OAAL,GAAe,EAAf;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,YAAL,GAAoB,EAApB;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,aAAL,GAAqB,EAArB;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,YAAL,GAAoB,EAApB;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,WAAL,GAAmB,EAAnB;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,UAAL,GAAkB,GAAlB;AACA;AACF;AACA;AACA;;AAEE,OAAKC,WAAL,GAAmB,CAAnB;AACA;AACF;AACA;AACA;;AAEE,OAAKC,QAAL;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE,OAAKC,UAAL,GAAkB,EAAlB;AACA;AACF;AACA;AACA;;AAEE,OAAKC,OAAL,GAAe,EAAf;AACA;AACF;AACA;AACA;AACA;AACA;;AAEE,OAAKC,kBAAL,GAA0B,EAA1B;AACA;AACF;AACA;AACA;AACA;;AAEE,OAAKC,kBAAL,GAA0B3E,mBAAmB,CA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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\nvar DataDimensionInfo = require(\"./DataDimensionInfo\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object|module:data/DataDimensionInfo>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo({\n        name: dimensionInfo\n      });\n    } else if (!(dimensionInfo instanceof DataDimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo(dimensionInfo);\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n  /**\n   * User output info of this data.\n   * DO NOT use it in other places!\n   *\n   * When preparing user params for user callbacks, we have\n   * to clone these inner data structures to prevent users\n   * from modifying them to effect built-in logic. And for\n   * performance consideration we make this `userOutput` to\n   * avoid clone them too many times.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.userOutput = this._dimensionsSummary.userOutput;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * The meanings of the input parameter `dim`:\n *\n * + If dim is a number (e.g., `1`), it means the index of the dimension.\n *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n * + If dim is a number-like string (e.g., `\"1\"`):\n *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n *     + If not, it will be converted to a number, which means the index of the dimension.\n *        (why? because of the backward compatbility. We have been tolerating number-like string in\n *        dimension setting, although now it seems that it is not a good idea.)\n *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n *     if no dimension name is defined as `\"1\"`.\n * + If dim is a not-number-like string, it means the concrete dim name.\n *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n *   or customized in `dimensions` property of option like `\"age\"`.\n *\n * Get dimension name\n * @param {string|number} dim See above.\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n    dim = this.dimensions[dim];\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        default label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    // Ordinal type originally can be string or number.\n    // But when an ordinal type is used on coord, it can\n    // not be string but only number. So we can also use isNaN.\n    if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  }\n\n  if (!this._indices) {\n    return rawIndex;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} If and only if multiple indices has\n *        the same value, they are put to the result.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Infinity;\n  var minDiff = -1;\n  var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i);\n    var dist = Math.abs(diff);\n\n    if (dist <= maxDistance) {\n      // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n      // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n      // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n      // So we chose the one that `diff >= 0` in this csae.\n      // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n      // should be push to `nearestIndices`.\n      if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndicesLen = 0;\n      }\n\n      if (diff === minDiff) {\n        nearestIndices[nearestIndicesLen++] = i;\n      }\n    }\n  }\n\n  nearestIndices.length = nearestIndicesLen;\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}