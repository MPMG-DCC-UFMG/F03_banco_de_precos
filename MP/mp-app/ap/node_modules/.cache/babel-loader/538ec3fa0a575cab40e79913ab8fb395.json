{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar numberUtil = require(\"../util/number\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * For testable.\n */\n\n\nvar roundNumber = numberUtil.round;\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\n\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  } // Tow more digital for tick.\n\n\n  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent\n\n  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\n\n\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return numberUtil.getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n\n\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\n\nexports.intervalScaleNiceTicks = intervalScaleNiceTicks;\nexports.getIntervalPrecision = getIntervalPrecision;\nexports.fixExtent = fixExtent;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/scale/helper.js"],"names":["numberUtil","require","roundNumber","round","intervalScaleNiceTicks","extent","splitNumber","minInterval","maxInterval","result","span","interval","nice","precision","intervalPrecision","getIntervalPrecision","niceTickExtent","Math","ceil","floor","fixExtent","getPrecisionSafe","clamp","idx","max","min","isFinite","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar numberUtil = require(\"../util/number\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * For testable.\n */\nvar roundNumber = numberUtil.round;\n/**\n * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n *                                Should be extent[0] < extent[1].\n * @param {number} splitNumber splitNumber should be >= 1.\n * @param {number} [minInterval]\n * @param {number} [maxInterval]\n * @return {Object} {interval, intervalPrecision, niceTickExtent}\n */\n\nfunction intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n  var result = {};\n  var span = extent[1] - extent[0];\n  var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n\n  if (minInterval != null && interval < minInterval) {\n    interval = result.interval = minInterval;\n  }\n\n  if (maxInterval != null && interval > maxInterval) {\n    interval = result.interval = maxInterval;\n  } // Tow more digital for tick.\n\n\n  var precision = result.intervalPrecision = getIntervalPrecision(interval); // Niced extent inside original extent\n\n  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n  fixExtent(niceTickExtent, extent);\n  return result;\n}\n/**\n * @param {number} interval\n * @return {number} interval precision\n */\n\n\nfunction getIntervalPrecision(interval) {\n  // Tow more digital for tick.\n  return numberUtil.getPrecisionSafe(interval) + 2;\n}\n\nfunction clamp(niceTickExtent, idx, extent) {\n  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n} // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n\n\nfunction fixExtent(niceTickExtent, extent) {\n  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n  clamp(niceTickExtent, 0, extent);\n  clamp(niceTickExtent, 1, extent);\n\n  if (niceTickExtent[0] > niceTickExtent[1]) {\n    niceTickExtent[0] = niceTickExtent[1];\n  }\n}\n\nexports.intervalScaleNiceTicks = intervalScaleNiceTicks;\nexports.getIntervalPrecision = getIntervalPrecision;\nexports.fixExtent = fixExtent;"]},"metadata":{},"sourceType":"script"}