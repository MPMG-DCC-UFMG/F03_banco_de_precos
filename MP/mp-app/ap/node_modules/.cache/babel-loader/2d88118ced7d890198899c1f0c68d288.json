{"ast":null,"code":"// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function LinkedList() {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function Entry(val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function LRU(maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/core/LRU.js"],"names":["LinkedList","head","tail","_len","linkedListProto","prototype","insert","val","entry","Entry","insertEntry","next","prev","remove","len","clear","value","LRU","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","put","key","list","map","removed","leastUsedEntry","get","_default","module","exports"],"mappings":"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","sourcesContent":["// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}