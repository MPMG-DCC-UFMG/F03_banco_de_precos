{"ast":null,"code":"var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  // This item default to be false. But in map series in echarts,\n  // in order to improve performance, it should be set to true,\n  // so the shorty segment won't draw.\n  segmentIgnoreThreshold: 0,\n\n  /**\n   * See `module:zrender/src/graphic/helper/subPixelOptimize`.\n   * @type {boolean}\n   */\n  subPixelOptimize: false,\n  brush: function brush(ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    if (hasFill) {\n      if (style.fillOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        path.fill(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.fill(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    if (hasStroke) {\n      if (style.strokeOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        path.stroke(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.stroke(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function buildPath(ctx, shapeCfg, inBundle) {},\n  createPathProxy: function createPathProxy() {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function getBoundingRect() {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function contain(x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function dirty(dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = this.__dirtyText = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function animateShape(loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function attrKV(key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function setShape(key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function getLineScale() {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function Sub(opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/graphic/Path.js"],"names":["Displayable","require","zrUtil","PathProxy","pathContain","Pattern","getCanvasPattern","prototype","abs","Math","pathProxyForDraw","Path","opts","call","path","constructor","type","__dirtyPath","strokeContainThreshold","segmentIgnoreThreshold","subPixelOptimize","brush","ctx","prevEl","style","hasStroke","hasFill","fill","stroke","hasFillGradient","colorStops","hasStrokeGradient","hasFillPattern","image","hasStrokePattern","bind","setTransform","__dirty","rect","getBoundingRect","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","scale","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","shape","rebuildPath","fillOpacity","originalGlobalAlpha","globalAlpha","opacity","strokeOpacity","text","restoreTransform","drawRectText","shapeCfg","inBundle","createPathProxy","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","clone","copy","w","lineWidth","lineScale","strokeNoScale","getLineScale","max","width","height","x","y","contain","localPos","transformCoordToLocal","pathData","data","containStroke","dirty","dirtyPath","__dirtyText","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","key","value","setShape","isObject","name","hasOwnProperty","m","transform","sqrt","extend","defaults","Sub","extendFrom","defaultShape","thisShape","init","inherits","_default","module","exports"],"mappings":"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","sourcesContent":["var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  // This item default to be false. But in map series in echarts,\n  // in order to improve performance, it should be set to true,\n  // so the shorty segment won't draw.\n  segmentIgnoreThreshold: 0,\n\n  /**\n   * See `module:zrender/src/graphic/helper/subPixelOptimize`.\n   * @type {boolean}\n   */\n  subPixelOptimize: false,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    if (hasFill) {\n      if (style.fillOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        path.fill(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.fill(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    if (hasStroke) {\n      if (style.strokeOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        path.stroke(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.stroke(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = this.__dirtyText = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}