{"ast":null,"code":"var Group = require(\"../container/Group\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Circle = require(\"../graphic/shape/Circle\");\n\nvar Rect = require(\"../graphic/shape/Rect\");\n\nvar Ellipse = require(\"../graphic/shape/Ellipse\");\n\nvar Line = require(\"../graphic/shape/Line\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar Polygon = require(\"../graphic/shape/Polygon\");\n\nvar Polyline = require(\"../graphic/shape/Polyline\");\n\nvar LinearGradient = require(\"../graphic/LinearGradient\");\n\nvar Style = require(\"../graphic/Style\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar _path = require(\"./path\");\n\nvar createFromString = _path.createFromString;\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar extend = _util.extend;\nvar defaults = _util.defaults;\nvar trim = _util.trim;\nvar each = _util.each; // import RadialGradient from '../graphic/RadialGradient';\n// import Pattern from '../graphic/Pattern';\n// import * as vector from '../core/vector';\n// Most of the values can be separated by comma and/or white space.\n\nvar DILIMITER_REG = /[\\s,]+/;\n/**\n * For big svg string, this method might be time consuming.\n *\n * @param {string} svg xml string\n * @return {Object} xml root.\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n\n  return svg;\n}\n\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\n\nSVGParser.prototype.parse = function (xml, opt) {\n  opt = opt || {};\n  var svg = parseXML(xml);\n\n  if (!svg) {\n    throw new Error('Illegal svg');\n  }\n\n  var root = new Group();\n  this._root = root; // parse view port\n\n  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n  // TODO: Other percent value not supported yet.\n\n  var width = parseFloat(svg.getAttribute('width') || opt.width);\n  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n  isNaN(width) && (width = null);\n  isNaN(height) && (height = null); // Apply inline style on svg element.\n\n  parseAttributes(svg, root, null, true);\n  var child = svg.firstChild;\n\n  while (child) {\n    this._parseNode(child, root);\n\n    child = child.nextSibling;\n  }\n\n  var viewBoxRect;\n  var viewBoxTransform;\n\n  if (viewBox) {\n    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n    if (viewBoxArr.length >= 4) {\n      viewBoxRect = {\n        x: parseFloat(viewBoxArr[0] || 0),\n        y: parseFloat(viewBoxArr[1] || 0),\n        width: parseFloat(viewBoxArr[2]),\n        height: parseFloat(viewBoxArr[3])\n      };\n    }\n  }\n\n  if (viewBoxRect && width != null && height != null) {\n    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n    if (!opt.ignoreViewBox) {\n      // If set transform on the output group, it probably bring trouble when\n      // some users only intend to show the clipped content inside the viewBox,\n      // but not intend to transform the output group. So we keep the output\n      // group no transform. If the user intend to use the viewBox as a\n      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n      // manually according to the viewBox info in the output of this method.\n      var elRoot = root;\n      root = new Group();\n      root.add(elRoot);\n      elRoot.scale = viewBoxTransform.scale.slice();\n      elRoot.position = viewBoxTransform.position.slice();\n    }\n  } // Some shapes might be overflow the viewport, which should be\n  // clipped despite whether the viewBox is used, as the SVG does.\n\n\n  if (!opt.ignoreRootClip && width != null && height != null) {\n    root.setClipPath(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }\n    }));\n  } // Set width/height on group just for output the viewport size.\n\n\n  return {\n    root: root,\n    width: width,\n    height: height,\n    viewBoxRect: viewBoxRect,\n    viewBoxTransform: viewBoxTransform\n  };\n};\n\nSVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n  // support <style>...</style> in svg, where nodeName is 'style',\n  // CSS classes is defined globally wherever the style tags are declared.\n\n  if (nodeName === 'defs') {\n    // define flag\n    this._isDefine = true;\n  } else if (nodeName === 'text') {\n    this._isText = true;\n  }\n\n  var el;\n\n  if (this._isDefine) {\n    var parser = defineParsers[nodeName];\n\n    if (parser) {\n      var def = parser.call(this, xmlNode);\n      var id = xmlNode.getAttribute('id');\n\n      if (id) {\n        this._defs[id] = def;\n      }\n    }\n  } else {\n    var parser = nodeParsers[nodeName];\n\n    if (parser) {\n      el = parser.call(this, xmlNode, parentGroup);\n      parentGroup.add(el);\n    }\n  }\n\n  var child = xmlNode.firstChild;\n\n  while (child) {\n    if (child.nodeType === 1) {\n      this._parseNode(child, el);\n    } // Is text\n\n\n    if (child.nodeType === 3 && this._isText) {\n      this._parseText(child, el);\n    }\n\n    child = child.nextSibling;\n  } // Quit define\n\n\n  if (nodeName === 'defs') {\n    this._isDefine = false;\n  } else if (nodeName === 'text') {\n    this._isText = false;\n  }\n};\n\nSVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n  if (xmlNode.nodeType === 1) {\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX += parseFloat(dx);\n    this._textY += parseFloat(dy);\n  }\n\n  var text = new Text({\n    style: {\n      text: xmlNode.textContent,\n      transformText: true\n    },\n    position: [this._textX || 0, this._textY || 0]\n  });\n  inheritStyle(parentGroup, text);\n  parseAttributes(xmlNode, text, this._defs);\n  var fontSize = text.style.fontSize;\n\n  if (fontSize && fontSize < 9) {\n    // PENDING\n    text.style.fontSize = 9;\n    text.scale = text.scale || [1, 1];\n    text.scale[0] *= fontSize / 9;\n    text.scale[1] *= fontSize / 9;\n  }\n\n  var rect = text.getBoundingRect();\n  this._textX += rect.width;\n  parentGroup.add(text);\n  return text;\n};\n\nvar nodeParsers = {\n  'g': function g(xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function rect(xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function circle(xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function line(xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function ellipse(xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function polygon(xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function polyline(xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function image(xmlNode, parentGroup) {\n    var img = new ZImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function text(xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function tspan(xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function path(xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function lineargradient(xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  },\n  'radialgradient': function radialgradient(xmlNode) {}\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var zrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);\n  }\n\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n\n  el.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          var value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Array.<number>} viewBoxRect\n * @param {number} width\n * @param {number} height\n * @return {Object} {scale, position}\n */\n\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\n * @param {string|XMLElement} xml\n * @param {Object} [opt]\n * @param {number} [opt.width] Default width if svg width not specified or is a percent value.\n * @param {number} [opt.height] Default height if svg height not specified or is a percent value.\n * @param {boolean} [opt.ignoreViewBox]\n * @param {boolean} [opt.ignoreRootClip]\n * @return {Object} result:\n * {\n *     root: Group, The root of the the result tree of zrender shapes,\n *     width: number, the viewport width of the SVG,\n *     height: number, the viewport height of the SVG,\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\n * }\n */\n\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/tool/parseSVG.js"],"names":["Group","require","ZImage","Text","Circle","Rect","Ellipse","Line","Path","Polygon","Polyline","LinearGradient","Style","matrix","_path","createFromString","_util","isString","extend","defaults","trim","each","DILIMITER_REG","parseXML","svg","parser","DOMParser","parseFromString","nodeType","firstChild","nodeName","toLowerCase","nextSibling","SVGParser","_defs","_root","_isDefine","_isText","prototype","parse","xml","opt","Error","root","viewBox","getAttribute","width","parseFloat","height","isNaN","parseAttributes","child","_parseNode","viewBoxRect","viewBoxTransform","viewBoxArr","split","length","x","y","makeViewBoxTransform","ignoreViewBox","elRoot","add","scale","slice","position","ignoreRootClip","setClipPath","shape","xmlNode","parentGroup","el","defineParsers","def","call","id","nodeParsers","_parseText","dx","dy","_textX","_textY","text","style","textContent","transformText","inheritStyle","fontSize","rect","getBoundingRect","g","setShape","circle","cx","cy","r","line","x1","y1","x2","y2","ellipse","rx","ry","points","parsePoints","polygon","path","polyline","img","setStyle","image","d","parseInt","gradient","_parseGradientColorStops","stop","offset","indexOf","stopColor","addColorStop","parent","__inheritedStyle","pointsString","list","i","push","attributesMap","defs","onlyInlineStyle","zrStyle","isTextEl","type","parseTransformAttribute","parseStyleAttribute","svgAttrName","hasOwnProperty","attrValue","elFillProp","elStrokeProp","elStyle","fill","set","getPaint","stroke","propName","elPropName","textBaseline","textAlign","lineDash","urlRegex","str","urlMatch","match","url","transformRegex","node","transform","replace","m","transformOps","value","create","translate","rotate","console","warn","setLocalTransform","styleRegex","result","styleList","lastIndex","styleRegResult","exec","scaleX","scaleY","Math","min","viewBoxScale","viewBoxPosition","parseSVG","exports"],"mappings":"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","sourcesContent":["var Group = require(\"../container/Group\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Circle = require(\"../graphic/shape/Circle\");\n\nvar Rect = require(\"../graphic/shape/Rect\");\n\nvar Ellipse = require(\"../graphic/shape/Ellipse\");\n\nvar Line = require(\"../graphic/shape/Line\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar Polygon = require(\"../graphic/shape/Polygon\");\n\nvar Polyline = require(\"../graphic/shape/Polyline\");\n\nvar LinearGradient = require(\"../graphic/LinearGradient\");\n\nvar Style = require(\"../graphic/Style\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar _path = require(\"./path\");\n\nvar createFromString = _path.createFromString;\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar extend = _util.extend;\nvar defaults = _util.defaults;\nvar trim = _util.trim;\nvar each = _util.each;\n// import RadialGradient from '../graphic/RadialGradient';\n// import Pattern from '../graphic/Pattern';\n// import * as vector from '../core/vector';\n// Most of the values can be separated by comma and/or white space.\nvar DILIMITER_REG = /[\\s,]+/;\n/**\n * For big svg string, this method might be time consuming.\n *\n * @param {string} svg xml string\n * @return {Object} xml root.\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n\n  return svg;\n}\n\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\n\nSVGParser.prototype.parse = function (xml, opt) {\n  opt = opt || {};\n  var svg = parseXML(xml);\n\n  if (!svg) {\n    throw new Error('Illegal svg');\n  }\n\n  var root = new Group();\n  this._root = root; // parse view port\n\n  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n  // TODO: Other percent value not supported yet.\n\n  var width = parseFloat(svg.getAttribute('width') || opt.width);\n  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n  isNaN(width) && (width = null);\n  isNaN(height) && (height = null); // Apply inline style on svg element.\n\n  parseAttributes(svg, root, null, true);\n  var child = svg.firstChild;\n\n  while (child) {\n    this._parseNode(child, root);\n\n    child = child.nextSibling;\n  }\n\n  var viewBoxRect;\n  var viewBoxTransform;\n\n  if (viewBox) {\n    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n    if (viewBoxArr.length >= 4) {\n      viewBoxRect = {\n        x: parseFloat(viewBoxArr[0] || 0),\n        y: parseFloat(viewBoxArr[1] || 0),\n        width: parseFloat(viewBoxArr[2]),\n        height: parseFloat(viewBoxArr[3])\n      };\n    }\n  }\n\n  if (viewBoxRect && width != null && height != null) {\n    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n    if (!opt.ignoreViewBox) {\n      // If set transform on the output group, it probably bring trouble when\n      // some users only intend to show the clipped content inside the viewBox,\n      // but not intend to transform the output group. So we keep the output\n      // group no transform. If the user intend to use the viewBox as a\n      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n      // manually according to the viewBox info in the output of this method.\n      var elRoot = root;\n      root = new Group();\n      root.add(elRoot);\n      elRoot.scale = viewBoxTransform.scale.slice();\n      elRoot.position = viewBoxTransform.position.slice();\n    }\n  } // Some shapes might be overflow the viewport, which should be\n  // clipped despite whether the viewBox is used, as the SVG does.\n\n\n  if (!opt.ignoreRootClip && width != null && height != null) {\n    root.setClipPath(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }\n    }));\n  } // Set width/height on group just for output the viewport size.\n\n\n  return {\n    root: root,\n    width: width,\n    height: height,\n    viewBoxRect: viewBoxRect,\n    viewBoxTransform: viewBoxTransform\n  };\n};\n\nSVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n  // support <style>...</style> in svg, where nodeName is 'style',\n  // CSS classes is defined globally wherever the style tags are declared.\n\n  if (nodeName === 'defs') {\n    // define flag\n    this._isDefine = true;\n  } else if (nodeName === 'text') {\n    this._isText = true;\n  }\n\n  var el;\n\n  if (this._isDefine) {\n    var parser = defineParsers[nodeName];\n\n    if (parser) {\n      var def = parser.call(this, xmlNode);\n      var id = xmlNode.getAttribute('id');\n\n      if (id) {\n        this._defs[id] = def;\n      }\n    }\n  } else {\n    var parser = nodeParsers[nodeName];\n\n    if (parser) {\n      el = parser.call(this, xmlNode, parentGroup);\n      parentGroup.add(el);\n    }\n  }\n\n  var child = xmlNode.firstChild;\n\n  while (child) {\n    if (child.nodeType === 1) {\n      this._parseNode(child, el);\n    } // Is text\n\n\n    if (child.nodeType === 3 && this._isText) {\n      this._parseText(child, el);\n    }\n\n    child = child.nextSibling;\n  } // Quit define\n\n\n  if (nodeName === 'defs') {\n    this._isDefine = false;\n  } else if (nodeName === 'text') {\n    this._isText = false;\n  }\n};\n\nSVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n  if (xmlNode.nodeType === 1) {\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX += parseFloat(dx);\n    this._textY += parseFloat(dy);\n  }\n\n  var text = new Text({\n    style: {\n      text: xmlNode.textContent,\n      transformText: true\n    },\n    position: [this._textX || 0, this._textY || 0]\n  });\n  inheritStyle(parentGroup, text);\n  parseAttributes(xmlNode, text, this._defs);\n  var fontSize = text.style.fontSize;\n\n  if (fontSize && fontSize < 9) {\n    // PENDING\n    text.style.fontSize = 9;\n    text.scale = text.scale || [1, 1];\n    text.scale[0] *= fontSize / 9;\n    text.scale[1] *= fontSize / 9;\n  }\n\n  var rect = text.getBoundingRect();\n  this._textX += rect.width;\n  parentGroup.add(text);\n  return text;\n};\n\nvar nodeParsers = {\n  'g': function (xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function (xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function (xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function (xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function (xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function (xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function (xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function (xmlNode, parentGroup) {\n    var img = new ZImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function (xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  },\n  'radialgradient': function (xmlNode) {}\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var zrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);\n  }\n\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n\n  el.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          var value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Array.<number>} viewBoxRect\n * @param {number} width\n * @param {number} height\n * @return {Object} {scale, position}\n */\n\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\n * @param {string|XMLElement} xml\n * @param {Object} [opt]\n * @param {number} [opt.width] Default width if svg width not specified or is a percent value.\n * @param {number} [opt.height] Default height if svg height not specified or is a percent value.\n * @param {boolean} [opt.ignoreViewBox]\n * @param {boolean} [opt.ignoreRootClip]\n * @return {Object} result:\n * {\n *     root: Group, The root of the the result tree of zrender shapes,\n *     width: number, the viewport width of the SVG,\n *     height: number, the viewport height of the SVG,\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\n * }\n */\n\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;"]},"metadata":{},"sourceType":"script"}