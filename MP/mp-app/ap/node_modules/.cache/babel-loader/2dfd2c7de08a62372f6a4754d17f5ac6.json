{"ast":null,"code":"var Animator = require(\"../animation/Animator\");\n\nvar logError = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n/**\n * @alias module:zrender/mixin/Animatable\n * @constructor\n */\n\nvar Animatable = function Animatable() {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function animate(path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      logError('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function stopAnimation(forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function animateTo(target, time, delay, easing, callback, forceAnimate) {\n    _animateTo(this, target, time, delay, easing, callback, forceAnimate);\n  },\n\n  /**\n   * Animate from the target state to current state.\n   * The params and the return value are the same as `this.animateTo`.\n   */\n  animateFrom: function animateFrom(target, time, delay, easing, callback, forceAnimate) {\n    _animateTo(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\n\nfunction _animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (isFunction(easing)) {\n      callback = easing;\n      easing = 'linear';\n      delay = 0;\n    } // animateTo(target, time, callback);\n    else if (isFunction(delay)) {\n        callback = delay;\n        delay = 0;\n      } // animateTo(target, callback)\n      else if (isFunction(time)) {\n          callback = time;\n          time = 500;\n        } // animateTo(target)\n        else if (!time) {\n            time = 500;\n          } // Stop all previous animations\n\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start\n  // if there is nothing to animate\n\n  var animators = animatable.animators.slice();\n  var count = animators.length;\n\n  function done() {\n    count--;\n\n    if (!count) {\n      callback && callback();\n    }\n  } // No animators. This should be checked before animators[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animators created\n  // Incase any animator is done immediately when all animation properties are not changed\n\n\n  for (var i = 0; i < animators.length; i++) {\n    animators[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\n * @param {string} path=''\n * @param {Object} source=animatable\n * @param {Object} target\n * @param {number} [time=500]\n * @param {number} [delay=0]\n * @param {boolean} [reverse] If `true`, animate\n *        from the `target` to current state.\n *\n * @example\n *  // Animate position\n *  el._animateToShallow({\n *      position: [10, 10]\n *  })\n *\n *  // Animate shape, style and position in 100ms, delayed 100ms\n *  el._animateToShallow({\n *      shape: {\n *          width: 500\n *      },\n *      style: {\n *          fill: 'red'\n *      }\n *      position: [10, 10]\n *  }, 100, 100)\n */\n\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n\n  for (var name in target) {\n    if (!target.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (source[name] != null) {\n      if (isObject(target[name]) && !isArrayLike(target[name])) {\n        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[name] = source[name];\n          setAttrByPath(animatable, path, name, target[name]);\n        } else {\n          objShallow[name] = target[name];\n        }\n\n        propertyCount++;\n      }\n    } else if (target[name] != null && !reverse) {\n      setAttrByPath(animatable, path, name, target[name]);\n    }\n  }\n\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\n\nfunction setAttrByPath(el, path, name, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(name, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][name] = value;\n    el.attr(props);\n  }\n}\n\nvar _default = Animatable;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/mixin/Animatable.js"],"names":["Animator","require","logError","_util","isString","isFunction","isObject","isArrayLike","indexOf","Animatable","animators","prototype","constructor","animate","path","loop","target","animatingShape","el","zr","__zr","pathSplitted","split","prop","i","l","length","id","animator","during","dirty","done","splice","push","animation","addAnimator","stopAnimation","forwardToLast","len","stop","animateTo","time","delay","easing","callback","forceAnimate","animateFrom","animatable","reverse","animateToShallow","slice","count","start","source","objShallow","propertyCount","name","hasOwnProperty","setAttrByPath","when","value","attr","props","_default","module","exports"],"mappings":"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","sourcesContent":["var Animator = require(\"../animation/Animator\");\n\nvar logError = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias module:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      logError('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate);\n  },\n\n  /**\n   * Animate from the target state to current state.\n   * The params and the return value are the same as `this.animateTo`.\n   */\n  animateFrom: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\n\nfunction animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (isFunction(easing)) {\n      callback = easing;\n      easing = 'linear';\n      delay = 0;\n    } // animateTo(target, time, callback);\n    else if (isFunction(delay)) {\n        callback = delay;\n        delay = 0;\n      } // animateTo(target, callback)\n      else if (isFunction(time)) {\n          callback = time;\n          time = 500;\n        } // animateTo(target)\n        else if (!time) {\n            time = 500;\n          } // Stop all previous animations\n\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start\n  // if there is nothing to animate\n\n  var animators = animatable.animators.slice();\n  var count = animators.length;\n\n  function done() {\n    count--;\n\n    if (!count) {\n      callback && callback();\n    }\n  } // No animators. This should be checked before animators[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animators created\n  // Incase any animator is done immediately when all animation properties are not changed\n\n\n  for (var i = 0; i < animators.length; i++) {\n    animators[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\n * @param {string} path=''\n * @param {Object} source=animatable\n * @param {Object} target\n * @param {number} [time=500]\n * @param {number} [delay=0]\n * @param {boolean} [reverse] If `true`, animate\n *        from the `target` to current state.\n *\n * @example\n *  // Animate position\n *  el._animateToShallow({\n *      position: [10, 10]\n *  })\n *\n *  // Animate shape, style and position in 100ms, delayed 100ms\n *  el._animateToShallow({\n *      shape: {\n *          width: 500\n *      },\n *      style: {\n *          fill: 'red'\n *      }\n *      position: [10, 10]\n *  }, 100, 100)\n */\n\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n\n  for (var name in target) {\n    if (!target.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (source[name] != null) {\n      if (isObject(target[name]) && !isArrayLike(target[name])) {\n        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[name] = source[name];\n          setAttrByPath(animatable, path, name, target[name]);\n        } else {\n          objShallow[name] = target[name];\n        }\n\n        propertyCount++;\n      }\n    } else if (target[name] != null && !reverse) {\n      setAttrByPath(animatable, path, name, target[name]);\n    }\n  }\n\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\n\nfunction setAttrByPath(el, path, name, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(name, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][name] = value;\n    el.attr(props);\n  }\n}\n\nvar _default = Animatable;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}