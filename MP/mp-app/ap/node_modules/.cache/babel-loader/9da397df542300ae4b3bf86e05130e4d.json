{"ast":null,"code":"var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fixShadow\");\n\nvar _constant = require(\"../constant\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  'use strict';\n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n      ctx.__attrCachedBy = ContextCachedBy.NONE;\n    }\n\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n\n  var computedFont = hostEl.__computedFont;\n\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/graphic/helper/text.js"],"names":["_util","require","retrieve2","retrieve3","each","normalizeCssArray","isString","isObject","textContain","roundRectHelper","imageHelper","fixShadow","_constant","ContextCachedBy","WILL_BE_RESTORED","DEFAULT_FONT","VALID_TEXT_ALIGN","left","right","center","VALID_TEXT_VERTICAL_ALIGN","top","bottom","middle","SHADOW_STYLE_COMMON_PROPS","_tmpTextPositionResult","_tmpBoxPositionResult","normalizeTextStyle","style","normalizeStyle","rich","font","makeFont","textAlign","textVerticalAlign","textBaseline","textPadding","renderText","hostEl","ctx","text","rect","prevEl","renderRichText","renderPlainText","needDrawBg","needDrawBackground","prevStyle","checkCache","cachedByMe","__attrCachedBy","PLAIN_TEXT","NONE","styleFont","computedFont","__computedFont","__styleFont","textLineHeight","contentBlock","__textCotentBlock","__dirtyText","parsePlainText","truncate","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","textWidth","getWidth","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","globalAlpha","opacity","i","length","propItem","styleProp","ctxProp","val","textStrokeWidth","textStrokeWidthPrev","strokeWidthChanged","strokeChanged","textStroke","getStroke","textFill","getFill","lineWidth","strokeStyle","fillStyle","strokeText","fillText","parseRichText","drawRichText","contentWidth","width","xLeft","lineTop","xRight","line","tokens","tokenCount","usedWidth","leftIndex","lineXLeft","lineXRight","rightIndex","token","placeToken","x","y","textRotation","origin","textOrigin","height","translate","rotate","tokenStyle","styleName","isLineHolder","textHeight","setCtx","textShadowBlur","textShadowColor","textShadowOffsetX","textShadowOffsetY","textBackgroundColor","textBorderWidth","textBorderColor","isPlainBg","textBoxShadowBlur","textBoxShadowColor","textBoxShadowOffsetX","textBoxShadowOffsetY","beginPath","textBorderRadius","buildPath","r","closePath","fillOpacity","originalGlobalAlpha","fill","image","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","strokeOpacity","stroke","out","textPosition","Array","parsePercent","res","calculateTextPosition","textOffset","prop","value","colorStops","maxValue","lastIndexOf","parseFloat","needDrawText","exports"],"mappings":"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","sourcesContent":["var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fixShadow\");\n\nvar _constant = require(\"../constant\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  'use strict';\n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n      ctx.__attrCachedBy = ContextCachedBy.NONE;\n    }\n\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n\n  var computedFont = hostEl.__computedFont;\n\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;"]},"metadata":{},"sourceType":"script"}