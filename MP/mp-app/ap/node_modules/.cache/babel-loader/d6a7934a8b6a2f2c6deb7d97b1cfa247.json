{"ast":null,"code":"var util = require(\"../core/util\");\n\nvar _event = require(\"../core/event\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = require(\"./requestAnimationFrame\");\n\nvar Animator = require(\"./Animator\");\n/**\n * Animation main class, dispatch and manage all animation controllers\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\n\n\nvar Animation = function Animation(options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   * Add clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function addClip(clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   * Add animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function addAnimator(animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * Delete animation clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function removeClip(clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * Delete animation clip\n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function removeAnimator(animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function _update() {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta); // 'frame' should be triggered before stage, because upper application\n    // depends on the sequence (e.g., echarts-stream and finish\n    // event judge)\n\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function _startLoop() {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * Start animation.\n   */\n  start: function start() {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * Stop animation.\n   */\n  stop: function stop() {\n    this._running = false;\n  },\n\n  /**\n   * Pause animation.\n   */\n  pause: function pause() {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume animation.\n   */\n  resume: function resume() {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * Clear animation.\n   */\n  clear: function clear() {\n    this._clips = [];\n  },\n\n  /**\n   * Whether animation finished.\n   */\n  isFinished: function isFinished() {\n    return !this._clips.length;\n  },\n\n  /**\n   * Creat animator for a target, whose props can be animated.\n   *\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] Whether loop animation.\n   * @param  {Function} [options.getter=null] Get value from target.\n   * @param  {Function} [options.setter=null] Set value to target.\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function animate(target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/animation/Animation.js"],"names":["util","require","_event","Dispatcher","requestAnimationFrame","Animator","Animation","options","stage","onframe","_clips","_running","_time","_pausedTime","_pauseStart","_paused","call","prototype","constructor","addClip","clip","push","addAnimator","animator","animation","clips","getClips","i","length","removeClip","idx","indexOf","splice","removeAnimator","_update","time","Date","getTime","delta","len","deferredEvents","deferredClips","e","step","_needsRemove","pop","fire","trigger","update","_startLoop","self","start","stop","pause","resume","clear","isFinished","animate","target","loop","getter","setter","mixin","_default","module","exports"],"mappings":"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","sourcesContent":["var util = require(\"../core/util\");\n\nvar _event = require(\"../core/event\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = require(\"./requestAnimationFrame\");\n\nvar Animator = require(\"./Animator\");\n\n/**\n * Animation main class, dispatch and manage all animation controllers\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   * Add clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   * Add animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * Delete animation clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * Delete animation clip\n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta); // 'frame' should be triggered before stage, because upper application\n    // depends on the sequence (e.g., echarts-stream and finish\n    // event judge)\n\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * Start animation.\n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * Stop animation.\n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause animation.\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume animation.\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * Clear animation.\n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * Whether animation finished.\n   */\n  isFinished: function () {\n    return !this._clips.length;\n  },\n\n  /**\n   * Creat animator for a target, whose props can be animated.\n   *\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] Whether loop animation.\n   * @param  {Function} [options.getter=null] Get value from target.\n   * @param  {Function} [options.setter=null] Set value to target.\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}