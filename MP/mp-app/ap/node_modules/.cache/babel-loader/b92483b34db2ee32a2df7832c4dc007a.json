{"ast":null,"code":"// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function diff(oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function equals(a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function tokenize(value) {\n    return value.slice();\n  },\n  join: function join(value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/core/arrayDiff2.js"],"names":["Diff","prototype","diff","oldArr","newArr","equals","a","b","self","slice","newLen","length","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","indices","i","push","count","execEditLength","diagonalPath","basePath","addPath","removePath","undefined","canAdd","canRemove","clonePath","pushComponent","buildValues","ret","added","removed","last","commonCount","tokenize","value","join","componentPos","componentLen","component","path","arrayDiff","_default","callback","module","exports"],"mappings":"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","sourcesContent":["// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function (oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function (a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function (components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function (basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function (value) {\n    return value.slice();\n  },\n  join: function (value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}