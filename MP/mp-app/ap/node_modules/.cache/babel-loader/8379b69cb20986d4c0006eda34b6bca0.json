{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar Axis = require(\"../Axis\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar inner = makeInner();\n\nfunction AngleAxis(scale, angleExtent) {\n  angleExtent = angleExtent || [0, 360];\n  Axis.call(this, 'angle', scale, angleExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = 'category';\n}\n\nAngleAxis.prototype = {\n  constructor: AngleAxis,\n\n  /**\n   * @override\n   */\n  pointToData: function pointToData(point, clamp) {\n    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n  },\n  dataToAngle: Axis.prototype.dataToCoord,\n  angleToData: Axis.prototype.coordToData,\n\n  /**\n   * Only be called in category axis.\n   * Angle axis uses text height to decide interval\n   *\n   * @override\n   * @return {number} Auto interval for cateogry axis tick and label\n   */\n  calculateCategoryInterval: function calculateCategoryInterval() {\n    var axis = this;\n    var labelModel = axis.getLabelModel();\n    var ordinalScale = axis.scale;\n    var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\n    // avoid generating a long array by `getTicks`\n    // in large category data case.\n\n    var tickCount = ordinalScale.count();\n\n    if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n      return 0;\n    }\n\n    var tickValue = ordinalExtent[0];\n    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n    var unitH = Math.abs(unitSpan); // Not precise, just use height as text width\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(tickValue, labelModel.getFont(), 'center', 'top');\n    var maxH = Math.max(rect.height, 7);\n    var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\n\n    isNaN(dh) && (dh = Infinity);\n    var interval = Math.max(0, Math.floor(dh));\n    var cache = inner(axis.model);\n    var lastAutoInterval = cache.lastAutoInterval;\n    var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\n    // otherwise the calculated interval might jitter when the zoom\n    // window size is close to the interval-changing size.\n\n    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\n    // point is not the same when zooming in or zooming out.\n    && lastAutoInterval > interval) {\n      interval = lastAutoInterval;\n    } // Only update cache if cache not used, otherwise the\n    // changing of interval is too insensitive.\n    else {\n        cache.lastTickCount = tickCount;\n        cache.lastAutoInterval = interval;\n      }\n\n    return interval;\n  }\n};\nzrUtil.inherits(AngleAxis, Axis);\nvar _default = AngleAxis;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/coord/polar/AngleAxis.js"],"names":["zrUtil","require","textContain","Axis","_model","makeInner","inner","AngleAxis","scale","angleExtent","call","type","prototype","constructor","pointToData","point","clamp","polar","dim","dataToAngle","dataToCoord","angleToData","coordToData","calculateCategoryInterval","axis","labelModel","getLabelModel","ordinalScale","ordinalExtent","getExtent","tickCount","count","tickValue","unitSpan","unitH","Math","abs","rect","getBoundingRect","getFont","maxH","max","height","dh","isNaN","Infinity","interval","floor","cache","model","lastAutoInterval","lastTickCount","inherits","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar Axis = require(\"../Axis\");\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\n\nfunction AngleAxis(scale, angleExtent) {\n  angleExtent = angleExtent || [0, 360];\n  Axis.call(this, 'angle', scale, angleExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = 'category';\n}\n\nAngleAxis.prototype = {\n  constructor: AngleAxis,\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n  },\n  dataToAngle: Axis.prototype.dataToCoord,\n  angleToData: Axis.prototype.coordToData,\n\n  /**\n   * Only be called in category axis.\n   * Angle axis uses text height to decide interval\n   *\n   * @override\n   * @return {number} Auto interval for cateogry axis tick and label\n   */\n  calculateCategoryInterval: function () {\n    var axis = this;\n    var labelModel = axis.getLabelModel();\n    var ordinalScale = axis.scale;\n    var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\n    // avoid generating a long array by `getTicks`\n    // in large category data case.\n\n    var tickCount = ordinalScale.count();\n\n    if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n      return 0;\n    }\n\n    var tickValue = ordinalExtent[0];\n    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n    var unitH = Math.abs(unitSpan); // Not precise, just use height as text width\n    // and each distance from axis line yet.\n\n    var rect = textContain.getBoundingRect(tickValue, labelModel.getFont(), 'center', 'top');\n    var maxH = Math.max(rect.height, 7);\n    var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\n\n    isNaN(dh) && (dh = Infinity);\n    var interval = Math.max(0, Math.floor(dh));\n    var cache = inner(axis.model);\n    var lastAutoInterval = cache.lastAutoInterval;\n    var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\n    // otherwise the calculated interval might jitter when the zoom\n    // window size is close to the interval-changing size.\n\n    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\n    // point is not the same when zooming in or zooming out.\n    && lastAutoInterval > interval) {\n      interval = lastAutoInterval;\n    } // Only update cache if cache not used, otherwise the\n    // changing of interval is too insensitive.\n    else {\n        cache.lastTickCount = tickCount;\n        cache.lastAutoInterval = interval;\n      }\n\n    return interval;\n  }\n};\nzrUtil.inherits(AngleAxis, Axis);\nvar _default = AngleAxis;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}