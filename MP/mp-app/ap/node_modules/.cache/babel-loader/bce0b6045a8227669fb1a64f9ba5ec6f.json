{"ast":null,"code":"var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\nvar getNativeEvent = _event.getNativeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n/* global document */\n\n\nvar TOUCH_CLICK_DELAY = 300;\nvar globalEventSupported = env.domSupported;\n\nvar localNativeListenerNames = function () {\n  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n  var pointerEventNameMap = {\n    pointerdown: 1,\n    pointerup: 1,\n    pointermove: 1,\n    pointerout: 1\n  };\n  var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n    var nm = name.replace('mouse', 'pointer');\n    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;\n  });\n  return {\n    mouse: mouseHandlerNames,\n    touch: touchHandlerNames,\n    pointer: pointerHandlerNames\n  };\n}();\n\nvar globalNativeListenerNames = {\n  mouse: ['mousemove', 'mouseup'],\n  pointer: ['pointermove', 'pointerup']\n};\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n *\n * @param {DOMHandlerScope} scope\n */\n\n\nfunction setTouchTimer(scope) {\n  scope.touching = true;\n\n  if (scope.touchTimer != null) {\n    clearTimeout(scope.touchTimer);\n    scope.touchTimer = null;\n  }\n\n  scope.touchTimer = setTimeout(function () {\n    scope.touching = false;\n    scope.touchTimer = null;\n  }, 700);\n} // Mark touch, which is useful in distinguish touch and\n// mouse event in upper applicatoin.\n\n\nfunction markTouch(event) {\n  event && (event.zrByTouch = true);\n} // function markTriggeredFromLocal(event) {\n//     event && (event.__zrIsFromLocal = true);\n// }\n// function isTriggeredFromLocal(instance, event) {\n//     return !!(event && event.__zrIsFromLocal);\n// }\n\n\nfunction normalizeGlobalEvent(instance, event) {\n  // offsetX, offsetY still need to be calculated. They are necessary in the event\n  // handlers of the upper applications. Set `true` to force calculate them.\n  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);\n}\n/**\n * Detect whether the given el is in `painterRoot`.\n */\n\n\nfunction isLocalEl(instance, el) {\n  var elTmp = el;\n  var isLocal = false;\n\n  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {\n    elTmp = elTmp.parentNode;\n  }\n\n  return isLocal;\n}\n/**\n * Make a fake event but not change the original event,\n * becuase the global event probably be used by other\n * listeners not belonging to zrender.\n * @class\n */\n\n\nfunction FakeGlobalEvent(instance, event) {\n  this.type = event.type;\n  this.target = this.currentTarget = instance.dom;\n  this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY\n\n  this.clientX = event.clientX;\n  this.clientY = event.clientY; // Because we do not mount global listeners to touch events,\n  // we do not copy `targetTouches` and `changedTouches` here.\n}\n\nvar fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,\n// otherwise it is dangerous. See more details in\n// [Drag outside] in `Handler.js`.\n\nfakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;\n/**\n * Local DOM Handlers\n * @this {HandlerProxy}\n */\n\nvar localDOMHandlers = {\n  mousedown: function mousedown(event) {\n    event = normalizeEvent(this.dom, event);\n    this._mayPointerCapture = [event.zrX, event.zrY];\n    this.trigger('mousedown', event);\n  },\n  mousemove: function mousemove(event) {\n    event = normalizeEvent(this.dom, event);\n    var downPoint = this._mayPointerCapture;\n\n    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {\n      togglePointerCapture(this, true);\n    }\n\n    this.trigger('mousemove', event);\n  },\n  mouseup: function mouseup(event) {\n    event = normalizeEvent(this.dom, event);\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n  },\n  mouseout: function mouseout(event) {\n    event = normalizeEvent(this.dom, event); // Similarly to the browser did on `document` and touch event,\n    // `globalout` will be delayed to final pointer cature release.\n\n    if (this._pointerCapturing) {\n      event.zrEventControl = 'no_globalout';\n    } // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n\n    var element = event.toElement || event.relatedTarget;\n    event.zrIsToLocalDOM = isLocalEl(this, element);\n    this.trigger('mouseout', event);\n  },\n  touchstart: function touchstart(event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this._lastTouchMoment = new Date();\n    this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,\n    // we simulate \"mouseover-->mousedown\" in touch device. So we trigger\n    // `mousemove` here (to trigger `mouseover` inside), and then trigger\n    // `mousedown`.\n\n    localDOMHandlers.mousemove.call(this, event);\n    localDOMHandlers.mousedown.call(this, event);\n  },\n  touchmove: function touchmove(event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    localDOMHandlers.mousemove.call(this, event);\n  },\n  touchend: function touchend(event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'end');\n    localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      localDOMHandlers.click.call(this, event);\n    }\n  },\n  pointerdown: function pointerdown(event) {\n    localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function pointermove(event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function pointerup(event) {\n    localDOMHandlers.mouseup.call(this, event);\n  },\n  pointerout: function pointerout(event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check localDOMHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mouseout.call(this, event);\n    }\n  }\n};\n/**\n * Othere DOM UI Event handlers for zr dom.\n * @this {HandlerProxy}\n */\n\nzrUtil.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  localDOMHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * DOM UI Event handlers for global page.\n *\n * [Caution]:\n * those handlers should both support in capture phase and bubble phase!\n *\n * @this {HandlerProxy}\n */\n\nvar globalDOMHandlers = {\n  pointermove: function pointermove(event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      globalDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function pointerup(event) {\n    globalDOMHandlers.mouseup.call(this, event);\n  },\n  mousemove: function mousemove(event) {\n    this.trigger('mousemove', event);\n  },\n  mouseup: function mouseup(event) {\n    var pointerCaptureReleasing = this._pointerCapturing;\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n\n    if (pointerCaptureReleasing) {\n      event.zrEventControl = 'only_globalout';\n      this.trigger('mouseout', event);\n    }\n  }\n};\n/**\n * @param {HandlerProxy} instance\n * @param {DOMHandlerScope} scope\n */\n\nfunction mountLocalDOMEventListeners(instance, scope) {\n  var domHandlers = scope.domHandlers;\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    zrUtil.each(localNativeListenerNames.pointer, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        // markTriggeredFromLocal(event);\n        domHandlers[nativeEventName].call(instance, event);\n      });\n    }); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      zrUtil.each(localNativeListenerNames.touch, function (nativeEventName) {\n        mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n          setTouchTimer(scope);\n        });\n      }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    zrUtil.each(localNativeListenerNames.mouse, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        event = getNativeEvent(event);\n\n        if (!scope.touching) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n        }\n      });\n    });\n  }\n}\n/**\n * @param {HandlerProxy} instance\n * @param {DOMHandlerScope} scope\n */\n\n\nfunction mountGlobalDOMEventListeners(instance, scope) {\n  // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.\n  if (env.pointerEventsSupported) {\n    zrUtil.each(globalNativeListenerNames.pointer, mount);\n  } // Touch event has implemented \"drag outside\" so we do not mount global listener for touch event.\n  // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)\n  // We do not consider \"both-support-touch-and-mouse device\" for this feature (see the comment of\n  // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.\n  else if (!env.touchEventsSupported) {\n      zrUtil.each(globalNativeListenerNames.mouse, mount);\n    }\n\n  function mount(nativeEventName) {\n    function nativeEventListener(event) {\n      event = getNativeEvent(event); // See the reason in [Drag outside] in `Handler.js`\n      // This checking supports both `useCapture` or not.\n      // PENDING: if there is performance issue in some devices,\n      // we probably can not use `useCapture` and change a easier\n      // to judes whether local (mark).\n\n      if (!isLocalEl(instance, event.target)) {\n        event = normalizeGlobalEvent(instance, event);\n        scope.domHandlers[nativeEventName].call(instance, event);\n      }\n    }\n\n    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {\n      capture: true\n    } // See [Drag Outside] in `Handler.js`\n    );\n  }\n}\n\nfunction mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {\n  scope.mounted[nativeEventName] = listener;\n  scope.listenerOpts[nativeEventName] = opt;\n  addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);\n}\n\nfunction unmountDOMEventListeners(scope) {\n  var mounted = scope.mounted;\n\n  for (var nativeEventName in mounted) {\n    if (mounted.hasOwnProperty(nativeEventName)) {\n      removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);\n    }\n  }\n\n  scope.mounted = {};\n}\n/**\n * See [Drag Outside] in `Handler.js`.\n * @implement\n * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.\n *        `true`: start to capture pointer if it is not capturing.\n *        `false`: end the capture if it is capturing.\n */\n\n\nfunction togglePointerCapture(instance, isPointerCapturing) {\n  instance._mayPointerCapture = null;\n\n  if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {\n    instance._pointerCapturing = isPointerCapturing;\n    var globalHandlerScope = instance._globalHandlerScope;\n    isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);\n  }\n}\n/**\n * @inner\n * @class\n */\n\n\nfunction DOMHandlerScope(domTarget, domHandlers) {\n  this.domTarget = domTarget;\n  this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.\n  // Used for unmount.\n\n  this.mounted = {};\n  this.listenerOpts = {};\n  this.touchTimer = null;\n  this.touching = false;\n}\n/**\n * @public\n * @class\n */\n\n\nfunction HandlerDomProxy(dom, painterRoot) {\n  Eventful.call(this);\n  this.dom = dom;\n  this.painterRoot = painterRoot;\n  this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);\n\n  if (globalEventSupported) {\n    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  this._pointerCapturing = false;\n  /**\n   * @type {Array.<number>} [x, y] or null.\n   */\n\n  this._mayPointerCapture = null;\n  mountLocalDOMEventListeners(this, this._localHandlerScope);\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  unmountDOMEventListeners(this._localHandlerScope);\n\n  if (globalEventSupported) {\n    unmountDOMEventListeners(this._globalHandlerScope);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/dom/HandlerProxy.js"],"names":["_event","require","addEventListener","removeEventListener","normalizeEvent","getNativeEvent","zrUtil","Eventful","env","TOUCH_CLICK_DELAY","globalEventSupported","domSupported","localNativeListenerNames","mouseHandlerNames","touchHandlerNames","pointerEventNameMap","pointerdown","pointerup","pointermove","pointerout","pointerHandlerNames","map","name","nm","replace","hasOwnProperty","mouse","touch","pointer","globalNativeListenerNames","eventNameFix","browser","firefox","isPointerFromTouch","event","pointerType","setTouchTimer","scope","touching","touchTimer","clearTimeout","setTimeout","markTouch","zrByTouch","normalizeGlobalEvent","instance","dom","FakeGlobalEvent","isLocalEl","el","elTmp","isLocal","nodeType","domBelongToZr","painterRoot","parentNode","type","target","currentTarget","clientX","clientY","fakeGlobalEventProto","prototype","stopPropagation","stopImmediatePropagation","preventDefault","noop","localDOMHandlers","mousedown","_mayPointerCapture","zrX","zrY","trigger","mousemove","downPoint","togglePointerCapture","mouseup","mouseout","_pointerCapturing","zrEventControl","element","toElement","relatedTarget","zrIsToLocalDOM","touchstart","_lastTouchMoment","Date","handler","processGesture","call","touchmove","touchend","click","each","globalDOMHandlers","pointerCaptureReleasing","mountLocalDOMEventListeners","domHandlers","pointerEventsSupported","nativeEventName","mountSingleDOMEventListener","touchEventsSupported","mountGlobalDOMEventListeners","mount","nativeEventListener","capture","listener","opt","mounted","listenerOpts","domTarget","unmountDOMEventListeners","isPointerCapturing","globalHandlerScope","_globalHandlerScope","DOMHandlerScope","HandlerDomProxy","_localHandlerScope","document","handlerDomProxyProto","dispose","setCursor","cursorStyle","style","cursor","mixin","_default","module","exports"],"mappings":"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","sourcesContent":["var _event = require(\"../core/event\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\nvar getNativeEvent = _event.getNativeEvent;\n\nvar zrUtil = require(\"../core/util\");\n\nvar Eventful = require(\"../mixin/Eventful\");\n\nvar env = require(\"../core/env\");\n\n/* global document */\nvar TOUCH_CLICK_DELAY = 300;\nvar globalEventSupported = env.domSupported;\n\nvar localNativeListenerNames = function () {\n  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n  var pointerEventNameMap = {\n    pointerdown: 1,\n    pointerup: 1,\n    pointermove: 1,\n    pointerout: 1\n  };\n  var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n    var nm = name.replace('mouse', 'pointer');\n    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;\n  });\n  return {\n    mouse: mouseHandlerNames,\n    touch: touchHandlerNames,\n    pointer: pointerHandlerNames\n  };\n}();\n\nvar globalNativeListenerNames = {\n  mouse: ['mousemove', 'mouseup'],\n  pointer: ['pointermove', 'pointerup']\n};\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n *\n * @param {DOMHandlerScope} scope\n */\n\n\nfunction setTouchTimer(scope) {\n  scope.touching = true;\n\n  if (scope.touchTimer != null) {\n    clearTimeout(scope.touchTimer);\n    scope.touchTimer = null;\n  }\n\n  scope.touchTimer = setTimeout(function () {\n    scope.touching = false;\n    scope.touchTimer = null;\n  }, 700);\n} // Mark touch, which is useful in distinguish touch and\n// mouse event in upper applicatoin.\n\n\nfunction markTouch(event) {\n  event && (event.zrByTouch = true);\n} // function markTriggeredFromLocal(event) {\n//     event && (event.__zrIsFromLocal = true);\n// }\n// function isTriggeredFromLocal(instance, event) {\n//     return !!(event && event.__zrIsFromLocal);\n// }\n\n\nfunction normalizeGlobalEvent(instance, event) {\n  // offsetX, offsetY still need to be calculated. They are necessary in the event\n  // handlers of the upper applications. Set `true` to force calculate them.\n  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);\n}\n/**\n * Detect whether the given el is in `painterRoot`.\n */\n\n\nfunction isLocalEl(instance, el) {\n  var elTmp = el;\n  var isLocal = false;\n\n  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {\n    elTmp = elTmp.parentNode;\n  }\n\n  return isLocal;\n}\n/**\n * Make a fake event but not change the original event,\n * becuase the global event probably be used by other\n * listeners not belonging to zrender.\n * @class\n */\n\n\nfunction FakeGlobalEvent(instance, event) {\n  this.type = event.type;\n  this.target = this.currentTarget = instance.dom;\n  this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY\n\n  this.clientX = event.clientX;\n  this.clientY = event.clientY; // Because we do not mount global listeners to touch events,\n  // we do not copy `targetTouches` and `changedTouches` here.\n}\n\nvar fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,\n// otherwise it is dangerous. See more details in\n// [Drag outside] in `Handler.js`.\n\nfakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;\n/**\n * Local DOM Handlers\n * @this {HandlerProxy}\n */\n\nvar localDOMHandlers = {\n  mousedown: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this._mayPointerCapture = [event.zrX, event.zrY];\n    this.trigger('mousedown', event);\n  },\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var downPoint = this._mayPointerCapture;\n\n    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {\n      togglePointerCapture(this, true);\n    }\n\n    this.trigger('mousemove', event);\n  },\n  mouseup: function (event) {\n    event = normalizeEvent(this.dom, event);\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n  },\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event); // Similarly to the browser did on `document` and touch event,\n    // `globalout` will be delayed to final pointer cature release.\n\n    if (this._pointerCapturing) {\n      event.zrEventControl = 'no_globalout';\n    } // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n\n    var element = event.toElement || event.relatedTarget;\n    event.zrIsToLocalDOM = isLocalEl(this, element);\n    this.trigger('mouseout', event);\n  },\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this._lastTouchMoment = new Date();\n    this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,\n    // we simulate \"mouseover-->mousedown\" in touch device. So we trigger\n    // `mousemove` here (to trigger `mouseover` inside), and then trigger\n    // `mousedown`.\n\n    localDOMHandlers.mousemove.call(this, event);\n    localDOMHandlers.mousedown.call(this, event);\n  },\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    localDOMHandlers.mousemove.call(this, event);\n  },\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'end');\n    localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      localDOMHandlers.click.call(this, event);\n    }\n  },\n  pointerdown: function (event) {\n    localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    localDOMHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check localDOMHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mouseout.call(this, event);\n    }\n  }\n};\n/**\n * Othere DOM UI Event handlers for zr dom.\n * @this {HandlerProxy}\n */\n\nzrUtil.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  localDOMHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * DOM UI Event handlers for global page.\n *\n * [Caution]:\n * those handlers should both support in capture phase and bubble phase!\n *\n * @this {HandlerProxy}\n */\n\nvar globalDOMHandlers = {\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      globalDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    globalDOMHandlers.mouseup.call(this, event);\n  },\n  mousemove: function (event) {\n    this.trigger('mousemove', event);\n  },\n  mouseup: function (event) {\n    var pointerCaptureReleasing = this._pointerCapturing;\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n\n    if (pointerCaptureReleasing) {\n      event.zrEventControl = 'only_globalout';\n      this.trigger('mouseout', event);\n    }\n  }\n};\n/**\n * @param {HandlerProxy} instance\n * @param {DOMHandlerScope} scope\n */\n\nfunction mountLocalDOMEventListeners(instance, scope) {\n  var domHandlers = scope.domHandlers;\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    zrUtil.each(localNativeListenerNames.pointer, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        // markTriggeredFromLocal(event);\n        domHandlers[nativeEventName].call(instance, event);\n      });\n    }); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      zrUtil.each(localNativeListenerNames.touch, function (nativeEventName) {\n        mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n          setTouchTimer(scope);\n        });\n      }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    zrUtil.each(localNativeListenerNames.mouse, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        event = getNativeEvent(event);\n\n        if (!scope.touching) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n        }\n      });\n    });\n  }\n}\n/**\n * @param {HandlerProxy} instance\n * @param {DOMHandlerScope} scope\n */\n\n\nfunction mountGlobalDOMEventListeners(instance, scope) {\n  // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.\n  if (env.pointerEventsSupported) {\n    zrUtil.each(globalNativeListenerNames.pointer, mount);\n  } // Touch event has implemented \"drag outside\" so we do not mount global listener for touch event.\n  // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)\n  // We do not consider \"both-support-touch-and-mouse device\" for this feature (see the comment of\n  // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.\n  else if (!env.touchEventsSupported) {\n      zrUtil.each(globalNativeListenerNames.mouse, mount);\n    }\n\n  function mount(nativeEventName) {\n    function nativeEventListener(event) {\n      event = getNativeEvent(event); // See the reason in [Drag outside] in `Handler.js`\n      // This checking supports both `useCapture` or not.\n      // PENDING: if there is performance issue in some devices,\n      // we probably can not use `useCapture` and change a easier\n      // to judes whether local (mark).\n\n      if (!isLocalEl(instance, event.target)) {\n        event = normalizeGlobalEvent(instance, event);\n        scope.domHandlers[nativeEventName].call(instance, event);\n      }\n    }\n\n    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {\n      capture: true\n    } // See [Drag Outside] in `Handler.js`\n    );\n  }\n}\n\nfunction mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {\n  scope.mounted[nativeEventName] = listener;\n  scope.listenerOpts[nativeEventName] = opt;\n  addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);\n}\n\nfunction unmountDOMEventListeners(scope) {\n  var mounted = scope.mounted;\n\n  for (var nativeEventName in mounted) {\n    if (mounted.hasOwnProperty(nativeEventName)) {\n      removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);\n    }\n  }\n\n  scope.mounted = {};\n}\n/**\n * See [Drag Outside] in `Handler.js`.\n * @implement\n * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.\n *        `true`: start to capture pointer if it is not capturing.\n *        `false`: end the capture if it is capturing.\n */\n\n\nfunction togglePointerCapture(instance, isPointerCapturing) {\n  instance._mayPointerCapture = null;\n\n  if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {\n    instance._pointerCapturing = isPointerCapturing;\n    var globalHandlerScope = instance._globalHandlerScope;\n    isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);\n  }\n}\n/**\n * @inner\n * @class\n */\n\n\nfunction DOMHandlerScope(domTarget, domHandlers) {\n  this.domTarget = domTarget;\n  this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.\n  // Used for unmount.\n\n  this.mounted = {};\n  this.listenerOpts = {};\n  this.touchTimer = null;\n  this.touching = false;\n}\n/**\n * @public\n * @class\n */\n\n\nfunction HandlerDomProxy(dom, painterRoot) {\n  Eventful.call(this);\n  this.dom = dom;\n  this.painterRoot = painterRoot;\n  this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);\n\n  if (globalEventSupported) {\n    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  this._pointerCapturing = false;\n  /**\n   * @type {Array.<number>} [x, y] or null.\n   */\n\n  this._mayPointerCapture = null;\n  mountLocalDOMEventListeners(this, this._localHandlerScope);\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  unmountDOMEventListeners(this._localHandlerScope);\n\n  if (globalEventSupported) {\n    unmountDOMEventListeners(this._globalHandlerScope);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}