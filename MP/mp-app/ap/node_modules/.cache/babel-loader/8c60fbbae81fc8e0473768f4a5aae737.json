{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./GridModel\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, Array.<module:echarts/coord/cartesian/Axis2D>>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  }); // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n\n  var onZeroRecords = {};\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = axisPositionUsed.left ? 'right' : 'left';\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/coord/cartesian/Grid.js"],"names":["_config","require","__DEV__","_util","isObject","each","map","indexOf","retrieve","_layout","getLayoutRect","_axisHelper","createScaleByModel","ifAxisCrossZero","niceScaleExtent","estimateLabelUnionRect","Cartesian2D","Axis2D","CoordinateSystem","_dataStackHelper","getStackedDimension","isAxisUsedInTheGrid","axisModel","gridModel","ecModel","getCoordSysModel","Grid","api","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","model","gridProto","prototype","type","axisPointerEnabled","getRect","_rect","update","axesMap","_updateScale","x","xAxis","scale","y","yAxis","onZeroRecords","fixAxisOnZero","resize","otherAxisDim","axis","getAxesOnZeroOf","otherAxisOnZeroOf","otherAxes","onZero","get","onZeroAxisIndex","canOnZeroToAxis","idx","hasOwnProperty","getOnZeroRecordKey","dim","index","ignoreContainLabel","gridRect","getBoxLayoutParams","width","getWidth","height","getHeight","axesList","adjustAxes","labelUnionRect","isHorizontal","margin","position","extent","inverse","setExtent","updateAxisTransform","getAxis","axisType","axisIndex","axesMapOnDim","name","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","i","coordList","length","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","toGlobalCoord","dataToCoord","convertFromPixel","pointToData","coordToData","toLocalCoord","seriesModel","xAxisModel","getReferringComponents","yAxisModel","coordsList","coordinateSystem","componentIndex","grid","containPoint","point","coord","axisPositionUsed","left","right","top","bottom","axesCount","eachComponent","createAxisCreator","push","addAxis","axisPosition","isCategory","onBand","Infinity","eachSeries","isCartesian2D","axesModels","findAxesModels","data","getData","unionExtent","mapDimension","unionExtentFromData","getTooltipAxes","baseAxes","baseAxis","getBaseAxis","otherAxis","getOtherAxis","coordBase","axisExtent","getExtent","axisExtentSum","axesTypes","create","grids","dimensions","register","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./GridModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, Array.<module:echarts/coord/cartesian/Axis2D>>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  }); // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n\n  var onZeroRecords = {};\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = axisPositionUsed.left ? 'right' : 'left';\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}