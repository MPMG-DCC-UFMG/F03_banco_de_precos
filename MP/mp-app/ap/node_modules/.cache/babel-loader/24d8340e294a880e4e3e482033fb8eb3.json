{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\n\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function init() {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function resetInner() {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.attr('position', selectorPos);\n    }\n\n    return mainRect;\n  },\n  _layoutContentAndController: function _layoutContentAndController(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function _pageGo(to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function _updatePageInfoView(legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n  _getPageInfo: function _getPageInfo(legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function _findTargetItemIndex(targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"names":["zrUtil","require","graphic","layoutUtil","LegendView","Group","WH","XY","ScrollableLegendView","extend","type","newlineDisabled","init","superCall","_currentIndex","group","add","_containerGroup","getContentGroup","_controllerGroup","_showController","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","selector","orient","selectorPosition","me","controllerGroup","pageIconSize","get","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","textFill","getTextColor","font","getFont","textVerticalAlign","textAlign","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","isFirstRender","selectorGroup","getSelectorGroup","orientIdx","index","wh","xy","hw","yx","box","selectorButtonGap","selectorRect","getBoundingRect","selectorPos","processMaxSize","clone","mainRect","_layoutContentAndController","offset","Math","max","min","attr","contentGroup","containerGroup","contentRect","controllerRect","showController","contentPos","position","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","clipShape","setClipPath","Rect","shape","eachChild","child","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","containerRectSize","targetItemIndex","_findTargetItemIndex","children","targetItem","itemCount","length","pCount","result","slice","pagePrevDataIndex","pageNextDataIndex","targetItemInfo","getItemInfo","s","i","winStartItemInfo","winEndItemInfo","currItemInfo","e","intersect","el","itemRect","start","__legendDataIndex","itemInfo","winStart","targetDataIndex","defaultIndex","idx","legendDataIdx","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.attr('position', selectorPos);\n    }\n\n    return mainRect;\n  },\n  _layoutContentAndController: function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup.position[orientIdx];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: contentGroup.position.slice(),\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el.position[orientIdx];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  },\n  _findTargetItemIndex: function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}