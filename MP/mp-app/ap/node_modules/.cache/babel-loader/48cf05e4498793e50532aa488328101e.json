{"ast":null,"code":"var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar logError = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n  if (clipPaths === prevClipPaths) {\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected\n\n  domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n  // dom does not act as expected) when some of the parent dom has\n  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n  // the canvas is not at the top part of the page.\n  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n  // this `overflow:hidden` to avoid the bug.\n  // 'overflow:hidden',\n  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function Painter(root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function getType() {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function isSingleCanvas() {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function getViewportRoot() {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function getViewportRootOffset() {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function refresh(paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function addHover(el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape,\n      z: el.z,\n      z2: el.z2,\n      silent: el.silent\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    hoverStyle && elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n\n    return elMirror;\n  },\n  removeHover: function removeHover(el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function clearHover(el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function refreshHover() {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function getHoverLayer() {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function _paintList(list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function _compositeManually() {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function _doPaintList(list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = el.__dirtyText = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function _doPaintEl(el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths;\n      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (prevElClipPaths) {\n          ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function getLayer(zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n          util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n        }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function insertLayer(zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      logError('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      logError('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function eachLayer(cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function eachBuiltinLayer(cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function eachOtherLayer(cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function getLayers() {\n    return this._layers;\n  },\n  _updateLayerStatus: function _updateLayerStatus(list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n    var prevZlevel;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer;\n\n      if (prevZlevel !== zlevel) {\n        prevZlevel = zlevel;\n        incrementalLayerCount = 0;\n      } // TODO Not use magic number on zlevel.\n      // Each layer with increment element can be separated to 3 layers.\n      //          (Other Element drawn after incremental element)\n      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------\n      //                      (Incremental element)\n      // ----------------------zlevel + INCREMENTAL_INC------------------------\n      //              (Element drawn before incremental element)\n      // --------------------------------zlevel--------------------------------\n\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function clear() {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function _clearLayer(layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function setBackgroundColor(backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function configLayer(zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function delLayer(zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function resize(width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width !== width || height !== this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function clearLayer(zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function dispose() {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function getRenderedCanvas(opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function getWidth() {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function getHeight() {\n    return this._height;\n  },\n  _getSize: function _getSize(whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function pathToImage(path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/Painter.js"],"names":["_config","require","devicePixelRatio","util","logError","BoundingRect","timsort","Layer","requestAnimationFrame","Image","env","HOVER_LAYER_ZLEVEL","CANVAS_ZLEVEL","EL_AFTER_INCREMENTAL_INC","INCREMENTAL_INC","parseInt10","val","parseInt","isLayerValid","layer","__builtin__","resize","refresh","tmpRect","viewRect","isDisplayableCulled","el","width","height","copy","getBoundingRect","transform","applyTransform","intersect","isClipPathChanged","clipPaths","prevClipPaths","length","i","doClip","ctx","clipPath","setTransform","beginPath","buildPath","shape","clip","restoreTransform","createRoot","domRoot","document","createElement","style","cssText","join","Painter","root","storage","opts","type","singleCanvas","nodeName","toUpperCase","_opts","extend","dpr","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_needsManuallyCompositing","_width","_getSize","_height","_domRoot","appendChild","mainLayer","initContext","zlevel","push","_hoverlayer","_hoverElements","prototype","constructor","getType","isSingleCanvas","getViewportRoot","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","list","getDisplayList","_redrawId","Math","random","_paintList","z","clearColor","_backgroundColor","refreshHover","addHover","hoverStyle","__hoverMir","elMirror","z2","silent","__from","setStyle","removeHover","hoverElements","idx","indexOf","splice","clearHover","from","len","hoverLayer","clear","displayableSortFunc","getLayer","scope","save","originalEl","__zr","invisible","invTransform","__clipPaths","_doPaintEl","restore","getHoverLayer","redrawId","_updateLayerStatus","finished","_doPaintList","_compositeManually","self","clearRect","eachBuiltinLayer","virtual","drawImage","dom","layerList","zi","__dirty","k","start","__startIndex","__drawIndex","useTimer","incremental","Date","now","startTime","__endIndex","firstEl","notClear","console","error","__dirtyText","dTime","prevElClipPaths","wxa","each","draw","currentLayer","forcePaint","m","opacity","culling","prevEl","beforeBrush","brush","afterBrush","merge","insertLayer","layersMap","prevLayer","prevDom","nextSibling","insertBefore","firstChild","eachLayer","cb","context","call","eachOtherLayer","getLayers","__used","updatePrevLayer","incrementalLayerCount","prevZlevel","id","getElementCount","_clearLayer","setBackgroundColor","backgroundColor","configLayer","config","layerConfig","_zlevel","delLayer","parentNode","removeChild","display","hasOwnProperty","_progressiveLayers","clearLayer","dispose","getRenderedCanvas","imageLayer","pixelRatio","renderToCanvas","displayList","getWidth","getHeight","whIdx","wh","cwh","plt","prb","parseFloat","stl","defaultView","getComputedStyle","pathToImage","path","canvas","getContext","rect","shadowBlurSize","shadowBlur","shadowOffsetX","shadowOffsetY","lineWidth","hasStroke","leftMargin","max","rightMargin","topMargin","bottomMargin","scale","pathTransform","position","rotation","x","y","updateTransform","ImageShape","imgShape","image","_default","module","exports"],"mappings":"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","sourcesContent":["var _config = require(\"./config\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = require(\"./core/util\");\n\nvar logError = require(\"./core/log\");\n\nvar BoundingRect = require(\"./core/BoundingRect\");\n\nvar timsort = require(\"./core/timsort\");\n\nvar Layer = require(\"./Layer\");\n\nvar requestAnimationFrame = require(\"./animation/requestAnimationFrame\");\n\nvar Image = require(\"./graphic/Image\");\n\nvar env = require(\"./core/env\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n  if (clipPaths === prevClipPaths) {\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected\n\n  domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n  // dom does not act as expected) when some of the parent dom has\n  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n  // the canvas is not at the top part of the page.\n  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n  // this `overflow:hidden` to avoid the bug.\n  // 'overflow:hidden',\n  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape,\n      z: el.z,\n      z2: el.z2,\n      silent: el.silent\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    hoverStyle && elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n\n    return elMirror;\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = el.__dirtyText = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths;\n      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (prevElClipPaths) {\n          ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n          util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n        }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      logError('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      logError('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n    var prevZlevel;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer;\n\n      if (prevZlevel !== zlevel) {\n        prevZlevel = zlevel;\n        incrementalLayerCount = 0;\n      } // TODO Not use magic number on zlevel.\n      // Each layer with increment element can be separated to 3 layers.\n      //          (Other Element drawn after incremental element)\n      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------\n      //                      (Incremental element)\n      // ----------------------zlevel + INCREMENTAL_INC------------------------\n      //              (Element drawn before incremental element)\n      // --------------------------------zlevel--------------------------------\n\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width !== width || height !== this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}