{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\nvar OrdinalMeta = require(\"../data/OrdinalMeta\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\n\n\nvar scaleProto = Scale.prototype;\nvar OrdinalScale = Scale.extend({\n  type: 'ordinal',\n\n  /**\n   * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta\n   */\n  init: function init(ordinalMeta, extent) {\n    // Caution: Should not use instanceof, consider ec-extensions using\n    // import approach to get OrdinalMeta class.\n    if (!ordinalMeta || zrUtil.isArray(ordinalMeta)) {\n      ordinalMeta = new OrdinalMeta({\n        categories: ordinalMeta\n      });\n    }\n\n    this._ordinalMeta = ordinalMeta;\n    this._extent = extent || [0, ordinalMeta.categories.length - 1];\n  },\n  parse: function parse(val) {\n    return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) // val might be float.\n    : Math.round(val);\n  },\n  contain: function contain(rank) {\n    rank = this.parse(rank);\n    return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;\n  },\n\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param {number|string} [val]\n   * @return {number}\n   */\n  normalize: function normalize(val) {\n    return scaleProto.normalize.call(this, this.parse(val));\n  },\n  scale: function scale(val) {\n    return Math.round(scaleProto.scale.call(this, val));\n  },\n\n  /**\n   * @return {Array}\n   */\n  getTicks: function getTicks() {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n\n    while (rank <= extent[1]) {\n      ticks.push(rank);\n      rank++;\n    }\n\n    return ticks;\n  },\n\n  /**\n   * Get item on rank n\n   * @param {number} n\n   * @return {string}\n   */\n  getLabel: function getLabel(n) {\n    if (!this.isBlank()) {\n      // Note that if no data, ordinalMeta.categories is an empty array.\n      return this._ordinalMeta.categories[n];\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  count: function count() {\n    return this._extent[1] - this._extent[0] + 1;\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function unionExtentFromData(data, dim) {\n    this.unionExtent(data.getApproximateExtent(dim));\n  },\n  getOrdinalMeta: function getOrdinalMeta() {\n    return this._ordinalMeta;\n  },\n  niceTicks: zrUtil.noop,\n  niceExtent: zrUtil.noop\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nOrdinalScale.create = function () {\n  return new OrdinalScale();\n};\n\nvar _default = OrdinalScale;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/scale/Ordinal.js"],"names":["zrUtil","require","Scale","OrdinalMeta","scaleProto","prototype","OrdinalScale","extend","type","init","ordinalMeta","extent","isArray","categories","_ordinalMeta","_extent","length","parse","val","getOrdinal","Math","round","contain","rank","call","normalize","scale","getTicks","ticks","push","getLabel","n","isBlank","count","unionExtentFromData","data","dim","unionExtent","getApproximateExtent","getOrdinalMeta","niceTicks","noop","niceExtent","create","_default","module","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Scale = require(\"./Scale\");\n\nvar OrdinalMeta = require(\"../data/OrdinalMeta\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n// FIXME only one data\nvar scaleProto = Scale.prototype;\nvar OrdinalScale = Scale.extend({\n  type: 'ordinal',\n\n  /**\n   * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta\n   */\n  init: function (ordinalMeta, extent) {\n    // Caution: Should not use instanceof, consider ec-extensions using\n    // import approach to get OrdinalMeta class.\n    if (!ordinalMeta || zrUtil.isArray(ordinalMeta)) {\n      ordinalMeta = new OrdinalMeta({\n        categories: ordinalMeta\n      });\n    }\n\n    this._ordinalMeta = ordinalMeta;\n    this._extent = extent || [0, ordinalMeta.categories.length - 1];\n  },\n  parse: function (val) {\n    return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) // val might be float.\n    : Math.round(val);\n  },\n  contain: function (rank) {\n    rank = this.parse(rank);\n    return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;\n  },\n\n  /**\n   * Normalize given rank or name to linear [0, 1]\n   * @param {number|string} [val]\n   * @return {number}\n   */\n  normalize: function (val) {\n    return scaleProto.normalize.call(this, this.parse(val));\n  },\n  scale: function (val) {\n    return Math.round(scaleProto.scale.call(this, val));\n  },\n\n  /**\n   * @return {Array}\n   */\n  getTicks: function () {\n    var ticks = [];\n    var extent = this._extent;\n    var rank = extent[0];\n\n    while (rank <= extent[1]) {\n      ticks.push(rank);\n      rank++;\n    }\n\n    return ticks;\n  },\n\n  /**\n   * Get item on rank n\n   * @param {number} n\n   * @return {string}\n   */\n  getLabel: function (n) {\n    if (!this.isBlank()) {\n      // Note that if no data, ordinalMeta.categories is an empty array.\n      return this._ordinalMeta.categories[n];\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  count: function () {\n    return this._extent[1] - this._extent[0] + 1;\n  },\n\n  /**\n   * @override\n   */\n  unionExtentFromData: function (data, dim) {\n    this.unionExtent(data.getApproximateExtent(dim));\n  },\n  getOrdinalMeta: function () {\n    return this._ordinalMeta;\n  },\n  niceTicks: zrUtil.noop,\n  niceExtent: zrUtil.noop\n});\n/**\n * @return {module:echarts/scale/Time}\n */\n\nOrdinalScale.create = function () {\n  return new OrdinalScale();\n};\n\nvar _default = OrdinalScale;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}