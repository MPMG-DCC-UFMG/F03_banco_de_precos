{"ast":null,"code":"var env = require(\"./env\");\n\nvar _fourPointsTransform = require(\"./fourPointsTransform\");\n\nvar buildTransformer = _fourPointsTransform.buildTransformer;\nvar EVENT_SAVED_PROP = '___zrEVENTSAVED';\nvar _calcOut = [];\n/**\n * Transform \"local coord\" from `elFrom` to `elTarget`.\n * \"local coord\": the coord based on the input `el`. The origin point is at\n *     the position of \"left: 0; top: 0;\" in the `el`.\n *\n * Support when CSS transform is used.\n *\n * Having the `out` (that is, `[outX, outY]`), we can create an DOM element\n * and set the CSS style as \"left: outX; top: outY;\" and append it to `elTarge`\n * to locate the element.\n *\n * For example, this code below positions a child of `document.body` on the event\n * point, no matter whether `body` has `margin`/`paddin`/`transfrom`/... :\n * ```js\n * transformLocalCoord(out, container, document.body, event.offsetX, event.offsetY);\n * if (!eqNaN(out[0])) {\n *     // Then locate the tip element on the event point.\n *     var tipEl = document.createElement('div');\n *     tipEl.style.cssText = 'position: absolute; left:' + out[0] + ';top:' + out[1] + ';';\n *     document.body.appendChild(tipEl);\n * }\n * ```\n *\n * Notice: In some env this method is not supported. If called, `out` will be `[NaN, NaN]`.\n *\n * @param {Array.<number>} out [inX: number, inY: number] The output..\n *        If can not transform, `out` will not be modified but return `false`.\n * @param {HTMLElement} elFrom The `[inX, inY]` is based on elFrom.\n * @param {HTMLElement} elTarget The `out` is based on elTarget.\n * @param {number} inX\n * @param {number} inY\n * @return {boolean} Whether transform successfully.\n */\n\nfunction transformLocalCoord(out, elFrom, elTarget, inX, inY) {\n  return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);\n}\n/**\n * Transform between a \"viewport coord\" and a \"local coord\".\n * \"viewport coord\": the coord based on the left-top corner of the viewport\n *     of the browser.\n * \"local coord\": the coord based on the input `el`. The origin point is at\n *     the position of \"left: 0; top: 0;\" in the `el`.\n *\n * Support the case when CSS transform is used on el.\n *\n * @param {Array.<number>} out [inX: number, inY: number] The output. If `inverse: false`,\n *        it represents \"local coord\", otherwise \"vireport coord\".\n *        If can not transform, `out` will not be modified but return `false`.\n * @param {HTMLElement} el The \"local coord\" is based on the `el`, see comment above.\n * @param {number} inX If `inverse: false`,\n *        it represents \"vireport coord\", otherwise \"local coord\".\n * @param {number} inY If `inverse: false`,\n *        it represents \"vireport coord\", otherwise \"local coord\".\n * @param {boolean} [inverse=false]\n *        `true`: from \"viewport coord\" to \"local coord\".\n *        `false`: from \"local coord\" to \"viewport coord\".\n * @return {boolean} Whether transform successfully.\n */\n\n\nfunction transformCoordWithViewport(out, el, inX, inY, inverse) {\n  if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {\n    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});\n    var markers = prepareCoordMarkers(el, saved);\n    var transformer = preparePointerTransformer(markers, saved, inverse);\n\n    if (transformer) {\n      transformer(out, inX, inY);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction prepareCoordMarkers(el, saved) {\n  var markers = saved.markers;\n\n  if (markers) {\n    return markers;\n  }\n\n  markers = saved.markers = [];\n  var propLR = ['left', 'right'];\n  var propTB = ['top', 'bottom'];\n\n  for (var i = 0; i < 4; i++) {\n    var marker = document.createElement('div');\n    var stl = marker.style;\n    var idxLR = i % 2;\n    var idxTB = (i >> 1) % 2;\n    stl.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', // 'width: 5px',\n    // 'height: 5px',\n    propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');\n    el.appendChild(marker);\n    markers.push(marker);\n  }\n\n  return markers;\n}\n\nfunction preparePointerTransformer(markers, saved, inverse) {\n  var transformerName = inverse ? 'invTrans' : 'trans';\n  var transformer = saved[transformerName];\n  var oldSrcCoords = saved.srcCoords;\n  var oldCoordTheSame = true;\n  var srcCoords = [];\n  var destCoords = [];\n\n  for (var i = 0; i < 4; i++) {\n    var rect = markers[i].getBoundingClientRect();\n    var ii = 2 * i;\n    var x = rect.left;\n    var y = rect.top;\n    srcCoords.push(x, y);\n    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];\n    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);\n  } // Cache to avoid time consuming of `buildTransformer`.\n\n\n  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));\n}\n\nfunction isCanvasEl(el) {\n  return el.nodeName.toUpperCase() === 'CANVAS';\n}\n\nexports.transformLocalCoord = transformLocalCoord;\nexports.transformCoordWithViewport = transformCoordWithViewport;\nexports.isCanvasEl = isCanvasEl;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/core/dom.js"],"names":["env","require","_fourPointsTransform","buildTransformer","EVENT_SAVED_PROP","_calcOut","transformLocalCoord","out","elFrom","elTarget","inX","inY","transformCoordWithViewport","el","inverse","getBoundingClientRect","domSupported","isCanvasEl","saved","markers","prepareCoordMarkers","transformer","preparePointerTransformer","propLR","propTB","i","marker","document","createElement","stl","style","idxLR","idxTB","cssText","join","appendChild","push","transformerName","oldSrcCoords","srcCoords","oldCoordTheSame","destCoords","rect","ii","x","left","y","top","offsetLeft","offsetTop","nodeName","toUpperCase","exports"],"mappings":"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","sourcesContent":["var env = require(\"./env\");\n\nvar _fourPointsTransform = require(\"./fourPointsTransform\");\n\nvar buildTransformer = _fourPointsTransform.buildTransformer;\nvar EVENT_SAVED_PROP = '___zrEVENTSAVED';\nvar _calcOut = [];\n/**\n * Transform \"local coord\" from `elFrom` to `elTarget`.\n * \"local coord\": the coord based on the input `el`. The origin point is at\n *     the position of \"left: 0; top: 0;\" in the `el`.\n *\n * Support when CSS transform is used.\n *\n * Having the `out` (that is, `[outX, outY]`), we can create an DOM element\n * and set the CSS style as \"left: outX; top: outY;\" and append it to `elTarge`\n * to locate the element.\n *\n * For example, this code below positions a child of `document.body` on the event\n * point, no matter whether `body` has `margin`/`paddin`/`transfrom`/... :\n * ```js\n * transformLocalCoord(out, container, document.body, event.offsetX, event.offsetY);\n * if (!eqNaN(out[0])) {\n *     // Then locate the tip element on the event point.\n *     var tipEl = document.createElement('div');\n *     tipEl.style.cssText = 'position: absolute; left:' + out[0] + ';top:' + out[1] + ';';\n *     document.body.appendChild(tipEl);\n * }\n * ```\n *\n * Notice: In some env this method is not supported. If called, `out` will be `[NaN, NaN]`.\n *\n * @param {Array.<number>} out [inX: number, inY: number] The output..\n *        If can not transform, `out` will not be modified but return `false`.\n * @param {HTMLElement} elFrom The `[inX, inY]` is based on elFrom.\n * @param {HTMLElement} elTarget The `out` is based on elTarget.\n * @param {number} inX\n * @param {number} inY\n * @return {boolean} Whether transform successfully.\n */\n\nfunction transformLocalCoord(out, elFrom, elTarget, inX, inY) {\n  return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);\n}\n/**\n * Transform between a \"viewport coord\" and a \"local coord\".\n * \"viewport coord\": the coord based on the left-top corner of the viewport\n *     of the browser.\n * \"local coord\": the coord based on the input `el`. The origin point is at\n *     the position of \"left: 0; top: 0;\" in the `el`.\n *\n * Support the case when CSS transform is used on el.\n *\n * @param {Array.<number>} out [inX: number, inY: number] The output. If `inverse: false`,\n *        it represents \"local coord\", otherwise \"vireport coord\".\n *        If can not transform, `out` will not be modified but return `false`.\n * @param {HTMLElement} el The \"local coord\" is based on the `el`, see comment above.\n * @param {number} inX If `inverse: false`,\n *        it represents \"vireport coord\", otherwise \"local coord\".\n * @param {number} inY If `inverse: false`,\n *        it represents \"vireport coord\", otherwise \"local coord\".\n * @param {boolean} [inverse=false]\n *        `true`: from \"viewport coord\" to \"local coord\".\n *        `false`: from \"local coord\" to \"viewport coord\".\n * @return {boolean} Whether transform successfully.\n */\n\n\nfunction transformCoordWithViewport(out, el, inX, inY, inverse) {\n  if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {\n    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});\n    var markers = prepareCoordMarkers(el, saved);\n    var transformer = preparePointerTransformer(markers, saved, inverse);\n\n    if (transformer) {\n      transformer(out, inX, inY);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction prepareCoordMarkers(el, saved) {\n  var markers = saved.markers;\n\n  if (markers) {\n    return markers;\n  }\n\n  markers = saved.markers = [];\n  var propLR = ['left', 'right'];\n  var propTB = ['top', 'bottom'];\n\n  for (var i = 0; i < 4; i++) {\n    var marker = document.createElement('div');\n    var stl = marker.style;\n    var idxLR = i % 2;\n    var idxTB = (i >> 1) % 2;\n    stl.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', // 'width: 5px',\n    // 'height: 5px',\n    propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');\n    el.appendChild(marker);\n    markers.push(marker);\n  }\n\n  return markers;\n}\n\nfunction preparePointerTransformer(markers, saved, inverse) {\n  var transformerName = inverse ? 'invTrans' : 'trans';\n  var transformer = saved[transformerName];\n  var oldSrcCoords = saved.srcCoords;\n  var oldCoordTheSame = true;\n  var srcCoords = [];\n  var destCoords = [];\n\n  for (var i = 0; i < 4; i++) {\n    var rect = markers[i].getBoundingClientRect();\n    var ii = 2 * i;\n    var x = rect.left;\n    var y = rect.top;\n    srcCoords.push(x, y);\n    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];\n    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);\n  } // Cache to avoid time consuming of `buildTransformer`.\n\n\n  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));\n}\n\nfunction isCanvasEl(el) {\n  return el.nodeName.toUpperCase() === 'CANVAS';\n}\n\nexports.transformLocalCoord = transformLocalCoord;\nexports.transformCoordWithViewport = transformCoordWithViewport;\nexports.isCanvasEl = isCanvasEl;"]},"metadata":{},"sourceType":"script"}