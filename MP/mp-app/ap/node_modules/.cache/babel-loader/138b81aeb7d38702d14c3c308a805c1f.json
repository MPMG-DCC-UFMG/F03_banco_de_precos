{"ast":null,"code":"var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\n * @public\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\n * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\n * To be removed. But still do not remove in case that some one has imported it.\n * @deprecated\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\n *  Notice: for performance, do not calculate outerWidth util needed.\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\n *  without travel the result `lines`.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/contain/text.js"],"names":["BoundingRect","require","imageHelper","_util","getContext","extend","retrieve2","retrieve3","trim","textWidthCache","textWidthCacheCounter","TEXT_CACHE_MAX","STYLE_REG","DEFAULT_FONT","methods","$override","name","fn","getWidth","text","font","key","textLines","split","width","i","l","length","Math","max","measureText","getBoundingRect","textAlign","textVerticalAlign","textPadding","textLineHeight","rich","truncate","getRichTextRect","getPlainTextRect","contentBlock","parsePlainText","outerWidth","outerHeight","x","adjustTextX","y","adjustTextY","rect","lineHeight","parseRichText","height","calculateTextPosition","out","style","textPosition","distance","textDistance","halfHeight","adjustTextPositionOnRect","dummyStyle","truncateText","containerWidth","ellipsis","options","prepareTruncateOptions","len","truncateSingleLine","join","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","charCode","charCodeAt","getLineHeight","ctx","padding","lines","canCacheByTextString","truncOuterHeight","truncOuterWidth","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","contentHeight","pendingList","stlPadding","truncateWidth","truncateHeight","line","tokens","token","tokenStyle","styleName","tokenHeight","textHeight","textWidth","tokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","bgImg","image","findExistImage","isImageReady","paddingW","remianTruncWidth","parseInt","block","str","isEmptyStr","strs","isLineHolder","tokensLen","makeFont","fontSize","fontFamily","fontStyle","fontWeight","textFont","exports"],"mappings":"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","sourcesContent":["var BoundingRect = require(\"../core/BoundingRect\");\n\nvar imageHelper = require(\"../graphic/helper/image\");\n\nvar _util = require(\"../core/util\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\n * @public\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\n * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\n * To be removed. But still do not remove in case that some one has imported it.\n * @deprecated\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\n *  Notice: for performance, do not calculate outerWidth util needed.\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\n *  without travel the result `lines`.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;"]},"metadata":{},"sourceType":"script"}