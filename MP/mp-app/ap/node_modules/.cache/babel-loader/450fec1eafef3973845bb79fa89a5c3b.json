{"ast":null,"code":"var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      image = new Image();\n      image.onload = image.onerror = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.onerror = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/graphic/helper/image.js"],"names":["LRU","require","globalImageCache","findExistImage","newImageOrSrc","cachedImgObj","get","image","createOrUpdateImage","hostEl","cb","cbPayload","__zrImageSrc","pendingWrap","isImageReady","pending","push","Image","onload","onerror","imageOnLoad","put","__cachedImgObj","src","i","length","dirty","width","height","exports"],"mappings":"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","sourcesContent":["var LRU = require(\"../../core/LRU\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      image = new Image();\n      image.onload = image.onerror = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.onerror = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;"]},"metadata":{},"sourceType":"script"}