{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar brushHelper = require(\"./brushHelper\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function grid(foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function geo(foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function grid() {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function geo() {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function rect(to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function polygon(to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function rect(values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function polygon(values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/component/helper/BrushTargetManager.js"],"names":["_config","require","__DEV__","zrUtil","graphic","modelUtil","brushHelper","each","indexOf","curry","COORD_CONVERTS","INCLUDE_FINDER_MAIN_TYPES","BrushTargetManager","option","ecModel","opt","targetInfoList","_targetInfoList","info","foundCpts","parseFinder","targetInfoBuilders","builder","type","include","proto","prototype","setOutputRanges","areas","matchOutputRanges","area","coordRange","coordSys","coordRanges","push","result","coordConvert","brushType","__rangeOffset","offset","diffProcessor","values","range","xyMinMax","cb","targetInfo","findTargetInfo","coordSyses","setInputRanges","panelId","rangeOffset","getScales","makePanelOpts","api","getDefaultBrushType","map","rect","getPanelRect","defaultBrushType","clipPath","makeRectPanelClipPath","isTargetByCursor","makeRectIsTargetByCursor","coordSysModel","getLinearBrushOtherExtent","makeLinearBrushOtherExtent","controlSeries","seriesModel","coordinateSystem","i","length","areaPanelId","targetInfoMatchers","formatMinMax","minMax","reverse","includeMainTypes","grid","xAxisModels","yAxisModels","gridModels","gridModelMap","createHashMap","xAxesHas","yAxesHas","axisModel","gridModel","axis","model","set","id","cartesians","getCartesians","cartesian","index","getAxis","panelRectBuilder","xAxisDeclared","yAxisDeclared","geo","geoModels","geoModel","xAxisModel","yAxisModel","getRect","clone","getBoundingRect","applyTransform","getTransform","lineX","axisConvert","lineY","to","rangeOrCoordRange","xminymin","xmaxymax","polygon","Infinity","item","p","Math","min","max","axisNameIndex","coordToData","toLocalCoord","toGlobalCoord","dataToCoord","NaN","axisDiffProcessor","refer","scales","idx","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","isNaN","_default","module","exports"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAArB;;AAEA,IAAIC,OAAO,GAAGF,OAAO,CAACE,OAAtB;;AAEA,IAAIC,MAAM,GAAGF,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIG,OAAO,GAAGH,OAAO,CAAC,oBAAD,CAArB;;AAEA,IAAII,SAAS,GAAGJ,OAAO,CAAC,kBAAD,CAAvB;;AAEA,IAAIK,WAAW,GAAGL,OAAO,CAAC,eAAD,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIM,IAAI,GAAGJ,MAAM,CAACI,IAAlB;AACA,IAAIC,OAAO,GAAGL,MAAM,CAACK,OAArB;AACA,IAAIC,KAAK,GAAGN,MAAM,CAACM,KAAnB;AACA,IAAIC,cAAc,GAAG,CAAC,aAAD,EAAgB,aAAhB,CAArB,C,CAAqD;AACrD;;AAEA,IAAIC,yBAAyB,GAAG,CAAC,MAAD,EAAS,OAAT,EAAkB,OAAlB,EAA2B,KAA3B,EAAkC,OAAlC,EAA2C,OAA3C,EAAoD,YAApD,EAAkE,WAAlE,EAA+E,MAA/E,CAAhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,kBAAT,CAA4BC,MAA5B,EAAoCC,OAApC,EAA6CC,GAA7C,EAAkD;AAChD;AACF;AACA;AACA;AACE,MAAIC,cAAc,GAAG,KAAKC,eAAL,GAAuB,EAA5C;AACA,MAAIC,IAAI,GAAG,EAAX;AA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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar brushHelper = require(\"./brushHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}