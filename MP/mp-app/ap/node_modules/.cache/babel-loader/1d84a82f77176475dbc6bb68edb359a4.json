{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\n\n\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function buildPath(ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function buildPath(ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/echarts/lib/chart/line/poly.js"],"names":["Path","require","vec2","fixClipWithShadow","vec2Min","min","vec2Max","max","scaleAndAdd","v2Copy","copy","v","cp0","cp1","isPointNull","p","isNaN","drawSegment","ctx","points","start","segLen","allLen","dir","smoothMin","smoothMax","smooth","smoothMonotone","connectNulls","drawNonMono","apply","arguments","drawMono","prevIdx","idx","k","prevP","dim","ctrlLen","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","sub","lenPrevSeg","lenNextSeg","Math","abs","dist","getBoundingBox","smoothConstraint","ptMin","Infinity","ptMax","i","length","pt","Polyline","extend","type","shape","style","fill","stroke","brush","prototype","buildPath","len","result","Polygon","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","closePath","exports"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;"]},"metadata":{},"sourceType":"script"}