{"ast":null,"code":"// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1;\n    var count2;\n    var exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/core/timsort.js"],"names":["DEFAULT_MIN_MERGE","DEFAULT_MIN_GALLOPING","DEFAULT_TMP_STORAGE_LENGTH","minRunLength","n","r","makeAscendingRun","array","lo","hi","compare","runHi","reverseRun","t","binaryInsertionSort","start","pivot","left","right","mid","gallopLeft","value","length","hint","lastOffset","maxOffset","offset","tmp","m","gallopRight","TimSort","minGallop","tmpStorageLength","stackLength","runStart","runLength","stackSize","pushRun","_runStart","_runLength","mergeRuns","mergeAt","forceMergeRuns","i","start1","length1","start2","length2","k","mergeLow","mergeHigh","cursor1","cursor2","dest","_minGallop","count1","count2","exit","Error","customCursor","customDest","sort","remaining","ts","minRun","force","module","exports"],"mappings":"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","sourcesContent":["// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1;\n    var count2;\n    var exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;"]},"metadata":{},"sourceType":"script"}