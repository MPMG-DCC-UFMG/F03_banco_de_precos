{"ast":null,"code":"var env = require(\"../core/env\");\n\nvar _vector = require(\"../core/vector\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar colorTool = require(\"../tool/color\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar RectText = require(\"../graphic/mixin/RectText\");\n\nvar Displayable = require(\"../graphic/Displayable\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar Gradient = require(\"../graphic/Gradient\");\n\nvar vmlCore = require(\"./core\"); // http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nvar CMD = PathProxy.CMD;\nvar round = Math.round;\nvar sqrt = Math.sqrt;\nvar abs = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax = Math.max;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function initRootElStyle(el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function encodeHtmlAttribute(s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function rgb2Str(r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function append(parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function remove(parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function getZIndex(zlevel, z, z2) {\n    // z 的取值范围为 [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = textHelper.parsePercent;\n  /***************************************************\n   * PATH\n   **************************************************/\n\n  var setColorAndOpacity = function setColorAndOpacity(el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function getColorAndAlpha(color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function updateFillNode(el, style, zrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = zrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = zrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var transform = zrEl.transform;\n          var scale = zrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function updateStrokeNode(el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function updateFillAndStroke(vmlEl, type, style, zrEl) {\n    var isFill = type === 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function pathDataToString(path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          var x1 = data[i++];\n          var y1 = data[i++];\n          var x2 = data[i++];\n          var y2 = data[i++];\n          var x3;\n          var y3;\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          var x = 0;\n          var y = 0;\n          var sx = 1;\n          var sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n          }\n\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // var psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          var x0 = cx + cos(startAngle) * rx;\n          var y0 = cy + sin(startAngle) * ry;\n          var x1 = cx + cos(endAngle) * rx;\n          var y1 = cy + sin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (Math.abs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (Math.abs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (Math.abs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = round(p0[0] * Z - Z2);\n          p1[0] = round(p1[0] * Z - Z2);\n          p0[1] = round(p0[1] * Z - Z2);\n          p1[1] = round(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); // 不 round 会非常慢\n\n          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  }; // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= sqrt(abs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      path.subPixelOptimize = false;\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * IMAGE\n   **************************************************/\n\n\n  var isImage = function isImage(img) {\n    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  }; // Rewrite the original path method\n\n\n  ZImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = round(x) + 'px';\n      vmlElStyle.top = round(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode !== cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = round(scaleX * dw) + 'px';\n      imageELStyle.height = round(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  ZImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  ZImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * TEXT\n   **************************************************/\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function getFontStyle(fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function drawRectText(vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // var fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      // 这里是在前面 appendChild 保证顺序的前提下\n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = round(x) + 'px';\n      textVmlElStyle.top = round(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash || null // style.lineDash can be `false`.\n\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function removeRectText(vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function appendRectText(vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/vml/graphic.js"],"names":["env","require","_vector","applyTransform","BoundingRect","colorTool","textContain","textHelper","RectText","Displayable","ZImage","Text","Path","PathProxy","Gradient","vmlCore","CMD","round","Math","sqrt","abs","cos","sin","mathMax","max","canvasSupported","comma","imageTransformPrefix","Z","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","el","style","cssText","coordsize","coordorigin","encodeHtmlAttribute","s","String","replace","rgb2Str","r","g","b","join","append","parent","child","parentNode","appendChild","remove","removeChild","getZIndex","zlevel","z","z2","parseFloat","parsePercent","setColorAndOpacity","color","opacity","colorArr","parse","isNaN","getColorAndAlpha","updateFillNode","zrEl","fill","gradientType","angle","focus","shift","expansion","rect","getBoundingRect","rectWidth","width","rectHeight","height","type","transform","p0","x","y","p1","x2","y2","dx","dy","atan2","PI","scale","dimension","stops","colorStops","slice","sort","cs1","cs2","offset","length","colorAndAlphaList","colors","i","stop","colorAndAlpha","push","color1","color2","opacity1","opacity2","method","focusposition","updateStrokeNode","lineDash","dashstyle","stroke","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","lineWidth","createNode","points","pathDataToString","path","m","M","C","L","A","Q","str","nPoint","cmdStr","cmd","xi","yi","data","dataLength","len","x1","y1","x3","y3","sx","sy","cx","cy","rx","ry","startAngle","endAngle","clockwise","x0","y0","R","k","p","prototype","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","strokeNoScale","det","weight","__dirtyPath","beginPath","subPixelOptimize","buildPath","shape","toStatic","zIndex","text","drawRectText","removeRectText","onRemove","onAdd","appendRectText","isImage","img","tagName","toUpperCase","image","ow","oh","src","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sWidth","sh","sHeight","hasCrop","doc","createElement","vmlElStyle","hasRotation","scaleX","scaleY","p2","p3","maxX","maxY","transformFilter","padding","filter","left","top","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","Image","self","onload","overflow","cropElStyle","filterStr","alpha","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","document","getFontStyle","fontString","fontStyle","fontFamily","font","split","e","variant","fontVariant","fontWeight","size","fontSize","family","textMeasureEl","$override","textFont","body","ex","innerHTML","createTextNode","offsetWidth","tmpRect","textRect","fromTextEl","__dirty","normalizeTextStyle","rich","contentBlock","parseRichText","lines","tokens","textLine","j","align","textAlign","verticalAlign","textVerticalAlign","textPadding","textLineHeight","copy","textPosition","Array","res","calculateTextPosition","adjustTextX","adjustTextY","textVmlEl","_textVmlEl","pathEl","textPathEl","skewEl","textpathok","on","from","to","firstChild","nextSibling","coords","textVmlElStyle","matrix","toFixed","origin","string","textFill","textStroke","list","proto"],"mappings":"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","sourcesContent":["var env = require(\"../core/env\");\n\nvar _vector = require(\"../core/vector\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar colorTool = require(\"../tool/color\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar RectText = require(\"../graphic/mixin/RectText\");\n\nvar Displayable = require(\"../graphic/Displayable\");\n\nvar ZImage = require(\"../graphic/Image\");\n\nvar Text = require(\"../graphic/Text\");\n\nvar Path = require(\"../graphic/Path\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar Gradient = require(\"../graphic/Gradient\");\n\nvar vmlCore = require(\"./core\");\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\nvar CMD = PathProxy.CMD;\nvar round = Math.round;\nvar sqrt = Math.sqrt;\nvar abs = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax = Math.max;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function (el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function (s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function (r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function (parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function (parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function (zlevel, z, z2) {\n    // z 的取值范围为 [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = textHelper.parsePercent;\n  /***************************************************\n   * PATH\n   **************************************************/\n\n  var setColorAndOpacity = function (el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function (color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function (el, style, zrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = zrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = zrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var transform = zrEl.transform;\n          var scale = zrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function (el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n    var isFill = type === 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function (path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          var x1 = data[i++];\n          var y1 = data[i++];\n          var x2 = data[i++];\n          var y2 = data[i++];\n          var x3;\n          var y3;\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          var x = 0;\n          var y = 0;\n          var sx = 1;\n          var sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n          }\n\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // var psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          var x0 = cx + cos(startAngle) * rx;\n          var y0 = cy + sin(startAngle) * ry;\n          var x1 = cx + cos(endAngle) * rx;\n          var y1 = cy + sin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (Math.abs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (Math.abs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (Math.abs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = round(p0[0] * Z - Z2);\n          p1[0] = round(p1[0] * Z - Z2);\n          p0[1] = round(p0[1] * Z - Z2);\n          p1[1] = round(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); // 不 round 会非常慢\n\n          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  }; // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= sqrt(abs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      path.subPixelOptimize = false;\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * IMAGE\n   **************************************************/\n\n\n  var isImage = function (img) {\n    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  }; // Rewrite the original path method\n\n\n  ZImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = round(x) + 'px';\n      vmlElStyle.top = round(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode !== cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = round(scaleX * dw) + 'px';\n      imageELStyle.height = round(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  ZImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  ZImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * TEXT\n   **************************************************/\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function (fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // var fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      // 这里是在前面 appendChild 保证顺序的前提下\n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = round(x) + 'px';\n      textVmlElStyle.top = round(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash || null // style.lineDash can be `false`.\n\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function (vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function (vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}"]},"metadata":{},"sourceType":"script"}