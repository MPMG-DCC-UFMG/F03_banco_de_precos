{"ast":null,"code":"var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\n\n\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n  if (displayable.__clipPaths) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/svg/helper/ClippathManager.js"],"names":["Definable","require","zrUtil","matrix","ClippathManager","zrId","svgRoot","call","inherits","prototype","update","displayable","svgEl","getSvgElement","updateDom","__clipPaths","textEl","getTextSvgElement","markUsed","parentEl","clipPaths","isText","length","defs","getDefs","clipPath","clipPathEl","id","dom","getAttribute","contains","appendChild","_zrId","nextId","createElement","setAttribute","svgProxy","getSvgProxy","transform","parent","invTransform","Array","slice","mul","brush","pathEl","innerHTML","cloneNode","that","each","_dom","_textDom","_default","module","exports"],"mappings":"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","sourcesContent":["var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n  if (displayable.__clipPaths) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}