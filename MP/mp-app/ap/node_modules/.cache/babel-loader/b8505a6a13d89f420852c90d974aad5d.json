{"ast":null,"code":"var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function Transformable(opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\nvar scaleTmp = [];\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  var globalScaleRatio = this.globalScaleRatio;\n\n  if (globalScaleRatio != null && globalScaleRatio !== 1) {\n    this.getGlobalScale(scaleTmp);\n    var relX = scaleTmp[0] < 0 ? -1 : 1;\n    var relY = scaleTmp[1] < 0 ? -1 : 1;\n    var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;\n    var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;\n    m[0] *= sx;\n    m[1] *= sx;\n    m[2] *= sy;\n    m[3] *= sy;\n  }\n\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\nvar originTransform = matrix.create();\n\ntransformableProto.setLocalTransform = function (m) {\n  if (!m) {\n    // TODO return or set identity?\n    return;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var origin = this.origin;\n\n  if (origin && (origin[0] || origin[1])) {\n    originTransform[4] = origin[0];\n    originTransform[5] = origin[1];\n    matrix.mul(tmpTransform, m, originTransform);\n    tmpTransform[4] -= origin[0];\n    tmpTransform[5] -= origin[1];\n    m = tmpTransform;\n  }\n\n  this.setLocalTransform(m);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function (out) {\n  var m = this.transform;\n  out = out || [];\n\n  if (!m) {\n    out[0] = 1;\n    out[1] = 1;\n    return out;\n  }\n\n  out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    out[0] = -out[0];\n  }\n\n  if (m[3] < 0) {\n    out[1] = -out[1];\n  }\n\n  return out;\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;","map":{"version":3,"sources":["/home/johnatan/MP/mp-app/ap/node_modules/zrender/lib/mixin/Transformable.js"],"names":["matrix","require","vector","mIdentity","identity","EPSILON","isNotAroundZero","val","Transformable","opts","position","rotation","scale","origin","transformableProto","prototype","transform","needLocalTransform","scaleTmp","updateTransform","parent","parentHasTransform","m","create","getLocalTransform","mul","copy","globalScaleRatio","getGlobalScale","relX","relY","sx","sy","invTransform","invert","setTransform","ctx","dpr","restoreTransform","tmpTransform","originTransform","setLocalTransform","Math","sqrt","atan2","decomposeTransform","out","transformCoordToLocal","x","y","v2","applyTransform","transformCoordToGlobal","target","rotate","_default","module","exports"],"mappings":"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","sourcesContent":["var matrix = require(\"../core/matrix\");\n\nvar vector = require(\"../core/vector\");\n\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\nvar scaleTmp = [];\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  var globalScaleRatio = this.globalScaleRatio;\n\n  if (globalScaleRatio != null && globalScaleRatio !== 1) {\n    this.getGlobalScale(scaleTmp);\n    var relX = scaleTmp[0] < 0 ? -1 : 1;\n    var relY = scaleTmp[1] < 0 ? -1 : 1;\n    var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;\n    var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;\n    m[0] *= sx;\n    m[1] *= sx;\n    m[2] *= sy;\n    m[3] *= sy;\n  }\n\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\nvar originTransform = matrix.create();\n\ntransformableProto.setLocalTransform = function (m) {\n  if (!m) {\n    // TODO return or set identity?\n    return;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var origin = this.origin;\n\n  if (origin && (origin[0] || origin[1])) {\n    originTransform[4] = origin[0];\n    originTransform[5] = origin[1];\n    matrix.mul(tmpTransform, m, originTransform);\n    tmpTransform[4] -= origin[0];\n    tmpTransform[5] -= origin[1];\n    m = tmpTransform;\n  }\n\n  this.setLocalTransform(m);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function (out) {\n  var m = this.transform;\n  out = out || [];\n\n  if (!m) {\n    out[0] = 1;\n    out[1] = 1;\n    return out;\n  }\n\n  out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    out[0] = -out[0];\n  }\n\n  if (m[3] < 0) {\n    out[1] = -out[1];\n  }\n\n  return out;\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}